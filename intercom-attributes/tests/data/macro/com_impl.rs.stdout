#![feature(prelude_import)]
#![no_std]
#[prelude_import]
use std::prelude::v1::*;
#[macro_use]
extern crate std;
extern crate intercom;
use intercom::*;
use std::mem::MaybeUninit;

// We need the IID and Vtbl to ensure this compiles.
//
// Normally these are provided by the [com_interface].
#[allow(non_camel_case_types)]
struct __Foo_AutomationVtbl;
const IID_Foo_Automation: intercom::IID = intercom::GUID {
    data1: 0,
    data2: 0,
    data3: 0,
    data4: [0, 0, 0, 0, 0, 0, 0, 0],
};

#[allow(non_camel_case_types)]
struct __Foo_RawVtbl;
const IID_Foo_Raw: intercom::IID = intercom::GUID {
    data1: 0,
    data2: 0,
    data3: 0,
    data4: [0, 0, 0, 0, 0, 0, 0, 0],
};

fn get_intercom_interface_info_for_Foo() -> Vec<intercom::typelib::TypeInfo> {
    unsafe { MaybeUninit::uninit().assume_init() }
}

pub struct Foo;
#[allow(non_snake_case)]
impl intercom::attributes::ComClass<Foo, intercom::type_system::AutomationTypeSystem> for Foo {
    #[inline(always)]
    fn offset() -> usize {
        unsafe { &intercom::ComBoxData::<Foo>::null_vtable().Foo_Automation as *const _ as usize }
    }
}
#[allow(non_snake_case)]
impl intercom::attributes::ComClass<Foo, intercom::type_system::RawTypeSystem> for Foo {
    #[inline(always)]
    fn offset() -> usize {
        unsafe { &intercom::ComBoxData::<Foo>::null_vtable().Foo_Raw as *const _ as usize }
    }
}
#[allow(non_upper_case_globals)]
impl
    intercom::attributes::ComImpl<
        intercom::ISupportErrorInfo,
        intercom::type_system::AutomationTypeSystem,
    > for Foo
{
    fn vtable()
     ->
         &'static <dyn intercom::ISupportErrorInfo as
intercom::attributes::ComInterface<intercom::type_system::AutomationTypeSystem>>::VTable{
        type T = <dyn intercom::ISupportErrorInfo as intercom::attributes::ComInterface<
            intercom::type_system::AutomationTypeSystem,
        >>::VTable;
        &T {
            __base: {
                type Vtbl = <dyn intercom::IUnknown as intercom::attributes::ComInterface<
                    intercom::type_system::AutomationTypeSystem,
                >>::VTable;
                Vtbl {
                    query_interface: intercom::ComBoxData::<Foo>::query_interface_ptr,
                    add_ref: intercom::ComBoxData::<Foo>::add_ref_ptr,
                    release: intercom::ComBoxData::<Foo>::release_ptr,
                }
            },
            interface_supports_error_info:
                intercom::ComBoxData::<Foo>::interface_supports_error_info_ptr,
        }
    }
}
impl intercom::HasInterface<intercom::IUnknown> for Foo {}
#[allow(non_snake_case)]
#[doc(hidden)]
pub struct __intercom_vtable_for_Foo {
    _ISupportErrorInfo:
        &'static <dyn intercom::ISupportErrorInfo as intercom::attributes::ComInterface<
            intercom::type_system::AutomationTypeSystem,
        >>::VTable,
    Foo_Automation: &'static <Foo as intercom::attributes::ComInterface<
        intercom::type_system::AutomationTypeSystem,
    >>::VTable,
    Foo_Raw: &'static <Foo as intercom::attributes::ComInterface<
        intercom::type_system::RawTypeSystem,
    >>::VTable,
}
#[allow(clippy::all)]
impl intercom::CoClass for Foo {
    type VTableList = __intercom_vtable_for_Foo;
    fn create_vtable_list() -> Self::VTableList {
        __intercom_vtable_for_Foo {
            _ISupportErrorInfo: <Foo as intercom::attributes::ComImpl<
                dyn intercom::ISupportErrorInfo,
                intercom::type_system::AutomationTypeSystem,
            >>::vtable(),
            Foo_Automation: <Foo as intercom::attributes::ComImpl<
                Foo,
                intercom::type_system::AutomationTypeSystem,
            >>::vtable(),
            Foo_Raw: <Foo as intercom::attributes::ComImpl<
                Foo,
                intercom::type_system::RawTypeSystem,
            >>::vtable(),
        }
    }
    fn query_interface(
        vtables: &Self::VTableList,
        riid: intercom::REFIID,
    ) -> intercom::RawComResult<intercom::RawComPtr> {
        if riid.is_null() {
            intercom::logging::error(|l| {
                l(
                    "testcrate",
                    ::core::fmt::Arguments::new_v1(
                        &["[", "] ", "::query_interface(NULL)"],
                        &match (&vtables, &"Foo") {
                            (arg0, arg1) => [
                                ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Pointer::fmt),
                                ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Display::fmt),
                            ],
                        },
                    ),
                )
            });
            return Err(intercom::raw::E_NOINTERFACE);
        }
        unsafe {
            let riid = &*riid;
            intercom::logging::trace(|l| {
                l(
                    "testcrate",
                    ::core::fmt::Arguments::new_v1_formatted(
                        &["[", "] ", "::query_interface(", ")"],
                        &match (&vtables, &"Foo", &riid) {
                            (arg0, arg1, arg2) => [
                                ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Pointer::fmt),
                                ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Display::fmt),
                                ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::UpperHex::fmt),
                            ],
                        },
                        &[
                            ::core::fmt::rt::v1::Argument {
                                position: ::core::fmt::rt::v1::Position::At(0usize),
                                format: ::core::fmt::rt::v1::FormatSpec {
                                    fill: ' ',
                                    align: ::core::fmt::rt::v1::Alignment::Unknown,
                                    flags: 0u32,
                                    precision: ::core::fmt::rt::v1::Count::Implied,
                                    width: ::core::fmt::rt::v1::Count::Implied,
                                },
                            },
                            ::core::fmt::rt::v1::Argument {
                                position: ::core::fmt::rt::v1::Position::At(1usize),
                                format: ::core::fmt::rt::v1::FormatSpec {
                                    fill: ' ',
                                    align: ::core::fmt::rt::v1::Alignment::Unknown,
                                    flags: 0u32,
                                    precision: ::core::fmt::rt::v1::Count::Implied,
                                    width: ::core::fmt::rt::v1::Count::Implied,
                                },
                            },
                            ::core::fmt::rt::v1::Argument {
                                position: ::core::fmt::rt::v1::Position::At(2usize),
                                format: ::core::fmt::rt::v1::FormatSpec {
                                    fill: ' ',
                                    align: ::core::fmt::rt::v1::Alignment::Unknown,
                                    flags: 2u32,
                                    precision: ::core::fmt::rt::v1::Count::Implied,
                                    width: ::core::fmt::rt::v1::Count::Implied,
                                },
                            },
                        ],
                    ),
                )
            });
            Ok(
                if riid
                    == <dyn intercom::IUnknown as intercom::attributes::ComInterface<
                        intercom::type_system::AutomationTypeSystem,
                    >>::iid()
                {
                    let ptr =
                       (&vtables._ISupportErrorInfo) as
                           *const &<dyn intercom::ISupportErrorInfo as
                                   intercom::attributes::ComInterface<intercom::type_system::AutomationTypeSystem>>::VTable
                           as
                           *mut &<dyn intercom::ISupportErrorInfo as
                                 intercom::attributes::ComInterface<intercom::type_system::AutomationTypeSystem>>::VTable
                           as intercom::RawComPtr;
                    intercom::logging::trace(|l| {
                        l(
                            "testcrate",
                            ::core::fmt::Arguments::new_v1_formatted(
                                &["[", "] ", "::query_interface(", ") -> IUnknown [", "]"],
                                &match (&vtables, &"Foo", &riid, &ptr) {
                                    (arg0, arg1, arg2, arg3) => [
                                        ::core::fmt::ArgumentV1::new(
                                            arg0,
                                            ::core::fmt::Pointer::fmt,
                                        ),
                                        ::core::fmt::ArgumentV1::new(
                                            arg1,
                                            ::core::fmt::Display::fmt,
                                        ),
                                        ::core::fmt::ArgumentV1::new(
                                            arg2,
                                            ::core::fmt::UpperHex::fmt,
                                        ),
                                        ::core::fmt::ArgumentV1::new(
                                            arg3,
                                            ::core::fmt::Pointer::fmt,
                                        ),
                                    ],
                                },
                                &[
                                    ::core::fmt::rt::v1::Argument {
                                        position: ::core::fmt::rt::v1::Position::At(0usize),
                                        format: ::core::fmt::rt::v1::FormatSpec {
                                            fill: ' ',
                                            align: ::core::fmt::rt::v1::Alignment::Unknown,
                                            flags: 0u32,
                                            precision: ::core::fmt::rt::v1::Count::Implied,
                                            width: ::core::fmt::rt::v1::Count::Implied,
                                        },
                                    },
                                    ::core::fmt::rt::v1::Argument {
                                        position: ::core::fmt::rt::v1::Position::At(1usize),
                                        format: ::core::fmt::rt::v1::FormatSpec {
                                            fill: ' ',
                                            align: ::core::fmt::rt::v1::Alignment::Unknown,
                                            flags: 0u32,
                                            precision: ::core::fmt::rt::v1::Count::Implied,
                                            width: ::core::fmt::rt::v1::Count::Implied,
                                        },
                                    },
                                    ::core::fmt::rt::v1::Argument {
                                        position: ::core::fmt::rt::v1::Position::At(2usize),
                                        format: ::core::fmt::rt::v1::FormatSpec {
                                            fill: ' ',
                                            align: ::core::fmt::rt::v1::Alignment::Unknown,
                                            flags: 2u32,
                                            precision: ::core::fmt::rt::v1::Count::Implied,
                                            width: ::core::fmt::rt::v1::Count::Implied,
                                        },
                                    },
                                    ::core::fmt::rt::v1::Argument {
                                        position: ::core::fmt::rt::v1::Position::At(3usize),
                                        format: ::core::fmt::rt::v1::FormatSpec {
                                            fill: ' ',
                                            align: ::core::fmt::rt::v1::Alignment::Unknown,
                                            flags: 0u32,
                                            precision: ::core::fmt::rt::v1::Count::Implied,
                                            width: ::core::fmt::rt::v1::Count::Implied,
                                        },
                                    },
                                ],
                            ),
                        )
                    });
                    ptr
                } else if riid
                    == <dyn intercom::ISupportErrorInfo as intercom::attributes::ComInterface<
                        intercom::type_system::AutomationTypeSystem,
                    >>::iid()
                {
                    let ptr =
                       (&vtables._ISupportErrorInfo) as
                           *const &<dyn intercom::ISupportErrorInfo as
                                   intercom::attributes::ComInterface<intercom::type_system::AutomationTypeSystem>>::VTable
                           as
                           *mut &<dyn intercom::ISupportErrorInfo as
                                 intercom::attributes::ComInterface<intercom::type_system::AutomationTypeSystem>>::VTable
                           as intercom::RawComPtr;
                    intercom::logging::trace(|l| {
                        l(
                            "testcrate",
                            ::core::fmt::Arguments::new_v1_formatted(
                                &[
                                    "[",
                                    "] ",
                                    "::query_interface(",
                                    ") -> ISupportErrorInfo [",
                                    "]",
                                ],
                                &match (&vtables, &"Foo", &riid, &ptr) {
                                    (arg0, arg1, arg2, arg3) => [
                                        ::core::fmt::ArgumentV1::new(
                                            arg0,
                                            ::core::fmt::Pointer::fmt,
                                        ),
                                        ::core::fmt::ArgumentV1::new(
                                            arg1,
                                            ::core::fmt::Display::fmt,
                                        ),
                                        ::core::fmt::ArgumentV1::new(
                                            arg2,
                                            ::core::fmt::UpperHex::fmt,
                                        ),
                                        ::core::fmt::ArgumentV1::new(
                                            arg3,
                                            ::core::fmt::Pointer::fmt,
                                        ),
                                    ],
                                },
                                &[
                                    ::core::fmt::rt::v1::Argument {
                                        position: ::core::fmt::rt::v1::Position::At(0usize),
                                        format: ::core::fmt::rt::v1::FormatSpec {
                                            fill: ' ',
                                            align: ::core::fmt::rt::v1::Alignment::Unknown,
                                            flags: 0u32,
                                            precision: ::core::fmt::rt::v1::Count::Implied,
                                            width: ::core::fmt::rt::v1::Count::Implied,
                                        },
                                    },
                                    ::core::fmt::rt::v1::Argument {
                                        position: ::core::fmt::rt::v1::Position::At(1usize),
                                        format: ::core::fmt::rt::v1::FormatSpec {
                                            fill: ' ',
                                            align: ::core::fmt::rt::v1::Alignment::Unknown,
                                            flags: 0u32,
                                            precision: ::core::fmt::rt::v1::Count::Implied,
                                            width: ::core::fmt::rt::v1::Count::Implied,
                                        },
                                    },
                                    ::core::fmt::rt::v1::Argument {
                                        position: ::core::fmt::rt::v1::Position::At(2usize),
                                        format: ::core::fmt::rt::v1::FormatSpec {
                                            fill: ' ',
                                            align: ::core::fmt::rt::v1::Alignment::Unknown,
                                            flags: 2u32,
                                            precision: ::core::fmt::rt::v1::Count::Implied,
                                            width: ::core::fmt::rt::v1::Count::Implied,
                                        },
                                    },
                                    ::core::fmt::rt::v1::Argument {
                                        position: ::core::fmt::rt::v1::Position::At(3usize),
                                        format: ::core::fmt::rt::v1::FormatSpec {
                                            fill: ' ',
                                            align: ::core::fmt::rt::v1::Alignment::Unknown,
                                            flags: 0u32,
                                            precision: ::core::fmt::rt::v1::Count::Implied,
                                            width: ::core::fmt::rt::v1::Count::Implied,
                                        },
                                    },
                                ],
                            ),
                        )
                    });
                    ptr
                } else if riid
                    == <Foo as intercom::attributes::ComInterface<
                        intercom::type_system::AutomationTypeSystem,
                    >>::iid()
                {
                    let ptr = &vtables.Foo_Automation
                        as *const &<Foo as intercom::attributes::ComInterface<
                            intercom::type_system::AutomationTypeSystem,
                        >>::VTable
                        as *mut &<Foo as intercom::attributes::ComInterface<
                            intercom::type_system::AutomationTypeSystem,
                        >>::VTable as intercom::RawComPtr;
                    intercom::logging::trace(|l| {
                        l(
                            "testcrate",
                            ::core::fmt::Arguments::new_v1_formatted(
                                &["[", "] ", "::query_interface(", ") -> ", " (", ") [", "]"],
                                &match (&vtables, &"Foo", &riid, &"Foo", &"Automation", &ptr) {
                                    (arg0, arg1, arg2, arg3, arg4, arg5) => [
                                        ::core::fmt::ArgumentV1::new(
                                            arg0,
                                            ::core::fmt::Pointer::fmt,
                                        ),
                                        ::core::fmt::ArgumentV1::new(
                                            arg1,
                                            ::core::fmt::Display::fmt,
                                        ),
                                        ::core::fmt::ArgumentV1::new(
                                            arg2,
                                            ::core::fmt::UpperHex::fmt,
                                        ),
                                        ::core::fmt::ArgumentV1::new(
                                            arg3,
                                            ::core::fmt::Display::fmt,
                                        ),
                                        ::core::fmt::ArgumentV1::new(
                                            arg4,
                                            ::core::fmt::Display::fmt,
                                        ),
                                        ::core::fmt::ArgumentV1::new(
                                            arg5,
                                            ::core::fmt::Pointer::fmt,
                                        ),
                                    ],
                                },
                                &[
                                    ::core::fmt::rt::v1::Argument {
                                        position: ::core::fmt::rt::v1::Position::At(0usize),
                                        format: ::core::fmt::rt::v1::FormatSpec {
                                            fill: ' ',
                                            align: ::core::fmt::rt::v1::Alignment::Unknown,
                                            flags: 0u32,
                                            precision: ::core::fmt::rt::v1::Count::Implied,
                                            width: ::core::fmt::rt::v1::Count::Implied,
                                        },
                                    },
                                    ::core::fmt::rt::v1::Argument {
                                        position: ::core::fmt::rt::v1::Position::At(1usize),
                                        format: ::core::fmt::rt::v1::FormatSpec {
                                            fill: ' ',
                                            align: ::core::fmt::rt::v1::Alignment::Unknown,
                                            flags: 0u32,
                                            precision: ::core::fmt::rt::v1::Count::Implied,
                                            width: ::core::fmt::rt::v1::Count::Implied,
                                        },
                                    },
                                    ::core::fmt::rt::v1::Argument {
                                        position: ::core::fmt::rt::v1::Position::At(2usize),
                                        format: ::core::fmt::rt::v1::FormatSpec {
                                            fill: ' ',
                                            align: ::core::fmt::rt::v1::Alignment::Unknown,
                                            flags: 2u32,
                                            precision: ::core::fmt::rt::v1::Count::Implied,
                                            width: ::core::fmt::rt::v1::Count::Implied,
                                        },
                                    },
                                    ::core::fmt::rt::v1::Argument {
                                        position: ::core::fmt::rt::v1::Position::At(3usize),
                                        format: ::core::fmt::rt::v1::FormatSpec {
                                            fill: ' ',
                                            align: ::core::fmt::rt::v1::Alignment::Unknown,
                                            flags: 0u32,
                                            precision: ::core::fmt::rt::v1::Count::Implied,
                                            width: ::core::fmt::rt::v1::Count::Implied,
                                        },
                                    },
                                    ::core::fmt::rt::v1::Argument {
                                        position: ::core::fmt::rt::v1::Position::At(4usize),
                                        format: ::core::fmt::rt::v1::FormatSpec {
                                            fill: ' ',
                                            align: ::core::fmt::rt::v1::Alignment::Unknown,
                                            flags: 0u32,
                                            precision: ::core::fmt::rt::v1::Count::Implied,
                                            width: ::core::fmt::rt::v1::Count::Implied,
                                        },
                                    },
                                    ::core::fmt::rt::v1::Argument {
                                        position: ::core::fmt::rt::v1::Position::At(5usize),
                                        format: ::core::fmt::rt::v1::FormatSpec {
                                            fill: ' ',
                                            align: ::core::fmt::rt::v1::Alignment::Unknown,
                                            flags: 0u32,
                                            precision: ::core::fmt::rt::v1::Count::Implied,
                                            width: ::core::fmt::rt::v1::Count::Implied,
                                        },
                                    },
                                ],
                            ),
                        )
                    });
                    ptr
                } else if riid
                    == <Foo as intercom::attributes::ComInterface<
                        intercom::type_system::RawTypeSystem,
                    >>::iid()
                {
                    let ptr = &vtables.Foo_Raw
                        as *const &<Foo as intercom::attributes::ComInterface<
                            intercom::type_system::RawTypeSystem,
                        >>::VTable
                        as *mut &<Foo as intercom::attributes::ComInterface<
                            intercom::type_system::RawTypeSystem,
                        >>::VTable as intercom::RawComPtr;
                    intercom::logging::trace(|l| {
                        l(
                            "testcrate",
                            ::core::fmt::Arguments::new_v1_formatted(
                                &["[", "] ", "::query_interface(", ") -> ", " (", ") [", "]"],
                                &match (&vtables, &"Foo", &riid, &"Foo", &"Raw", &ptr) {
                                    (arg0, arg1, arg2, arg3, arg4, arg5) => [
                                        ::core::fmt::ArgumentV1::new(
                                            arg0,
                                            ::core::fmt::Pointer::fmt,
                                        ),
                                        ::core::fmt::ArgumentV1::new(
                                            arg1,
                                            ::core::fmt::Display::fmt,
                                        ),
                                        ::core::fmt::ArgumentV1::new(
                                            arg2,
                                            ::core::fmt::UpperHex::fmt,
                                        ),
                                        ::core::fmt::ArgumentV1::new(
                                            arg3,
                                            ::core::fmt::Display::fmt,
                                        ),
                                        ::core::fmt::ArgumentV1::new(
                                            arg4,
                                            ::core::fmt::Display::fmt,
                                        ),
                                        ::core::fmt::ArgumentV1::new(
                                            arg5,
                                            ::core::fmt::Pointer::fmt,
                                        ),
                                    ],
                                },
                                &[
                                    ::core::fmt::rt::v1::Argument {
                                        position: ::core::fmt::rt::v1::Position::At(0usize),
                                        format: ::core::fmt::rt::v1::FormatSpec {
                                            fill: ' ',
                                            align: ::core::fmt::rt::v1::Alignment::Unknown,
                                            flags: 0u32,
                                            precision: ::core::fmt::rt::v1::Count::Implied,
                                            width: ::core::fmt::rt::v1::Count::Implied,
                                        },
                                    },
                                    ::core::fmt::rt::v1::Argument {
                                        position: ::core::fmt::rt::v1::Position::At(1usize),
                                        format: ::core::fmt::rt::v1::FormatSpec {
                                            fill: ' ',
                                            align: ::core::fmt::rt::v1::Alignment::Unknown,
                                            flags: 0u32,
                                            precision: ::core::fmt::rt::v1::Count::Implied,
                                            width: ::core::fmt::rt::v1::Count::Implied,
                                        },
                                    },
                                    ::core::fmt::rt::v1::Argument {
                                        position: ::core::fmt::rt::v1::Position::At(2usize),
                                        format: ::core::fmt::rt::v1::FormatSpec {
                                            fill: ' ',
                                            align: ::core::fmt::rt::v1::Alignment::Unknown,
                                            flags: 2u32,
                                            precision: ::core::fmt::rt::v1::Count::Implied,
                                            width: ::core::fmt::rt::v1::Count::Implied,
                                        },
                                    },
                                    ::core::fmt::rt::v1::Argument {
                                        position: ::core::fmt::rt::v1::Position::At(3usize),
                                        format: ::core::fmt::rt::v1::FormatSpec {
                                            fill: ' ',
                                            align: ::core::fmt::rt::v1::Alignment::Unknown,
                                            flags: 0u32,
                                            precision: ::core::fmt::rt::v1::Count::Implied,
                                            width: ::core::fmt::rt::v1::Count::Implied,
                                        },
                                    },
                                    ::core::fmt::rt::v1::Argument {
                                        position: ::core::fmt::rt::v1::Position::At(4usize),
                                        format: ::core::fmt::rt::v1::FormatSpec {
                                            fill: ' ',
                                            align: ::core::fmt::rt::v1::Alignment::Unknown,
                                            flags: 0u32,
                                            precision: ::core::fmt::rt::v1::Count::Implied,
                                            width: ::core::fmt::rt::v1::Count::Implied,
                                        },
                                    },
                                    ::core::fmt::rt::v1::Argument {
                                        position: ::core::fmt::rt::v1::Position::At(5usize),
                                        format: ::core::fmt::rt::v1::FormatSpec {
                                            fill: ' ',
                                            align: ::core::fmt::rt::v1::Alignment::Unknown,
                                            flags: 0u32,
                                            precision: ::core::fmt::rt::v1::Count::Implied,
                                            width: ::core::fmt::rt::v1::Count::Implied,
                                        },
                                    },
                                ],
                            ),
                        )
                    });
                    ptr
                } else {
                    intercom::logging::trace(|l| {
                        l(
                            "testcrate",
                            ::core::fmt::Arguments::new_v1_formatted(
                                &["[", "] ", "::query_interface(", ") -> E_NOINTERFACE"],
                                &match (&vtables, &"Foo", &riid) {
                                    (arg0, arg1, arg2) => [
                                        ::core::fmt::ArgumentV1::new(
                                            arg0,
                                            ::core::fmt::Pointer::fmt,
                                        ),
                                        ::core::fmt::ArgumentV1::new(
                                            arg1,
                                            ::core::fmt::Display::fmt,
                                        ),
                                        ::core::fmt::ArgumentV1::new(
                                            arg2,
                                            ::core::fmt::UpperHex::fmt,
                                        ),
                                    ],
                                },
                                &[
                                    ::core::fmt::rt::v1::Argument {
                                        position: ::core::fmt::rt::v1::Position::At(0usize),
                                        format: ::core::fmt::rt::v1::FormatSpec {
                                            fill: ' ',
                                            align: ::core::fmt::rt::v1::Alignment::Unknown,
                                            flags: 0u32,
                                            precision: ::core::fmt::rt::v1::Count::Implied,
                                            width: ::core::fmt::rt::v1::Count::Implied,
                                        },
                                    },
                                    ::core::fmt::rt::v1::Argument {
                                        position: ::core::fmt::rt::v1::Position::At(1usize),
                                        format: ::core::fmt::rt::v1::FormatSpec {
                                            fill: ' ',
                                            align: ::core::fmt::rt::v1::Alignment::Unknown,
                                            flags: 0u32,
                                            precision: ::core::fmt::rt::v1::Count::Implied,
                                            width: ::core::fmt::rt::v1::Count::Implied,
                                        },
                                    },
                                    ::core::fmt::rt::v1::Argument {
                                        position: ::core::fmt::rt::v1::Position::At(2usize),
                                        format: ::core::fmt::rt::v1::FormatSpec {
                                            fill: ' ',
                                            align: ::core::fmt::rt::v1::Alignment::Unknown,
                                            flags: 2u32,
                                            precision: ::core::fmt::rt::v1::Count::Implied,
                                            width: ::core::fmt::rt::v1::Count::Implied,
                                        },
                                    },
                                ],
                            ),
                        )
                    });
                    return Err(intercom::raw::E_NOINTERFACE);
                },
            )
        }
    }
    fn interface_supports_error_info(riid: intercom::REFIID) -> bool {
        if riid.is_null() {
            return false;
        }
        unsafe {
            let riid = &*riid;
            if riid
                == <Foo as intercom::attributes::ComInterface<
                    intercom::type_system::AutomationTypeSystem,
                >>::iid()
            {
                true
            } else if riid
                == <Foo as intercom::attributes::ComInterface<
                    intercom::type_system::RawTypeSystem,
                >>::iid()
            {
                true
            } else {
                false
            }
        }
    }
}
#[allow(non_upper_case_globals)]
#[doc = "`Foo` class ID."]
pub const CLSID_Foo: intercom::CLSID = intercom::GUID {
    data1: 0u32,
    data2: 0u16,
    data3: 0u16,
    data4: [0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8],
};
impl intercom::attributes::HasTypeInfo for Foo {
    fn gather_type_info() -> Vec<intercom::typelib::TypeInfo> {
        let mut r =




            // Should be VARIANT_BOOL in Automation interface.

            <[_]>::into_vec(box
                                [intercom::typelib::TypeInfo::Class(intercom::ComBox::new(intercom::typelib::CoClass::__new("Foo".into(),
                                                                                                                            intercom::GUID{data1:
                                                                                                                                               0u32,
                                                                                                                                           data2:
                                                                                                                                               0u16,
                                                                                                                                           data3:
                                                                                                                                               0u16,
                                                                                                                                           data4:
                                                                                                                                               [0u8,
                                                                                                                                                0u8,
                                                                                                                                                0u8,
                                                                                                                                                0u8,
                                                                                                                                                0u8,
                                                                                                                                                0u8,
                                                                                                                                                0u8,
                                                                                                                                                0u8],},
                                                                                                                            <[_]>::into_vec(box
                                                                                                                                                [intercom::typelib::InterfaceRef{name:
                                                                                                                                                                                     "Foo".into(),
                                                                                                                                                                                 iid_automation:
                                                                                                                                                                                     <Foo
                                                                                                                                                                                         as
                                                                                                                                                                                         intercom::attributes::ComInterface<intercom::type_system::AutomationTypeSystem>>::iid().clone(),
                                                                                                                                                                                 iid_raw:
                                                                                                                                                                                     <Foo
                                                                                                                                                                                         as
                                                                                                                                                                                         intercom::attributes::ComInterface<intercom::type_system::RawTypeSystem>>::iid().clone(),}]))))]);
        r.extend(<Foo as intercom::attributes::InterfaceHasTypeInfo>::gather_type_info());
        r
    }
}
impl Foo {
    fn static_method(a: u16, b: i16) {}
    fn simple_method(&self) {}
    fn arg_method(&self, a: u16) {}
    fn simple_result_method(&self) -> u16 {
        0
    }
    fn com_result_method(&self) -> ComResult<u16> {
        Ok(0)
    }
    fn rust_result_method(&self) -> Result<u16, i32> {
        Ok(0)
    }
    fn tuple_result_method(&self) -> Result<(u8, u16, u32), i32> {
        Ok(0)
    }
    fn string_method(&self, input: String) -> String {
        input
    }
    fn string_result_method(&self, input: String) -> ComResult<String> {
        Ok(input)
    }
    fn complete_method(&mut self, a: u16, b: i16) -> ComResult<bool> {
        Ok(true)
    }
    fn bool_method(&self, input: bool) -> ComResult<bool> {
        Ok(input)
    }
    fn variant_method(&self, input: Variant) -> ComResult<Variant> {
        Ok(input)
    }
}
#[allow(non_snake_case)]
#[doc(hidden)]
unsafe extern "system" fn __Foo_Foo_Automation_query_interface(
    self_vtable: intercom::RawComPtr,
    riid: <intercom::REFIID as intercom::type_system::ExternType<
        intercom::type_system::AutomationTypeSystem,
    >>::ExternInputType,
    out: *mut <intercom::RawComPtr as intercom::type_system::ExternType<
        intercom::type_system::AutomationTypeSystem,
    >>::ExternOutputType,
) -> <intercom::raw::HRESULT as intercom::type_system::ExternType<
    intercom::type_system::AutomationTypeSystem,
>>::ExternOutputType {
    let self_ptr = (self_vtable as usize
        - <Foo as intercom::attributes::ComClass<
            Foo,
            intercom::type_system::AutomationTypeSystem,
        >>::offset()) as *mut _;
    intercom::logging::trace(|l| {
        l(
            "testcrate",
            ::core::fmt::Arguments::new_v1(
                &["[", ", through ", "] Serving ", "::query_interface"],
                &match (&self_ptr, &self_vtable, &"Foo") {
                    (arg0, arg1, arg2) => [
                        ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Pointer::fmt),
                        ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Pointer::fmt),
                        ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                    ],
                },
            ),
        )
    });
    intercom::ComBoxData::<Foo>::query_interface(&mut *self_ptr, riid, out)
}
#[allow(non_snake_case)]
#[allow(dead_code)]
#[doc(hidden)]
unsafe extern "system" fn __Foo_Foo_Automation_add_ref(self_vtable:
                                                           intercom::RawComPtr)
 ->
     <u32 as
intercom::type_system::ExternType<intercom::type_system::AutomationTypeSystem>>::ExternOutputType{
    let self_ptr = (self_vtable as usize
        - <Foo as intercom::attributes::ComClass<
            Foo,
            intercom::type_system::AutomationTypeSystem,
        >>::offset()) as *mut _;
    intercom::logging::trace(|l| {
        l(
            "testcrate",
            ::core::fmt::Arguments::new_v1(
                &["[", ", through ", "] Serving ", "::add_ref"],
                &match (&self_ptr, &self_vtable, &"Foo") {
                    (arg0, arg1, arg2) => [
                        ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Pointer::fmt),
                        ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Pointer::fmt),
                        ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                    ],
                },
            ),
        )
    });
    intercom::ComBoxData::<Foo>::add_ref_ptr(self_ptr)
}
#[allow(non_snake_case)]
#[allow(dead_code)]
#[doc(hidden)]
unsafe extern "system" fn __Foo_Foo_Automation_release(self_vtable:
                                                           intercom::RawComPtr)
 ->
     <u32 as
intercom::type_system::ExternType<intercom::type_system::AutomationTypeSystem>>::ExternOutputType{
    let self_ptr = (self_vtable as usize
        - <Foo as intercom::attributes::ComClass<
            Foo,
            intercom::type_system::AutomationTypeSystem,
        >>::offset()) as *mut _;
    intercom::logging::trace(|l| {
        l(
            "testcrate",
            ::core::fmt::Arguments::new_v1(
                &["[", ", through ", "] Serving ", "::release_ptr"],
                &match (&self_ptr, &self_vtable, &"Foo") {
                    (arg0, arg1, arg2) => [
                        ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Pointer::fmt),
                        ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Pointer::fmt),
                        ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                    ],
                },
            ),
        )
    });
    intercom::ComBoxData::<Foo>::release_ptr(self_ptr)
}
#[allow(non_snake_case)]
#[allow(dead_code)]
#[doc(hidden)]
unsafe extern "system" fn __Foo_Foo_Automation_simple_method_Automation(self_vtable:
                                                                            intercom::RawComPtr)
 ->
     <() as
intercom::type_system::ExternType<intercom::type_system::AutomationTypeSystem>>::ExternOutputType{
    let self_combox = (self_vtable as usize
        - <Foo as intercom::attributes::ComClass<
            Foo,
            intercom::type_system::AutomationTypeSystem,
        >>::offset()) as *mut intercom::ComBoxData<Foo>;
    use intercom::type_system::{IntercomFrom, IntercomInto};
    let result:
            Result<<() as
                   intercom::type_system::ExternType<intercom::type_system::AutomationTypeSystem>>::ExternOutputType,
                   intercom::ComError> =
        (||
             {
                 intercom::logging::trace(|l|
                                              l("testcrate",
                                                ::core::fmt::Arguments::new_v1(&["[",
                                                                                 ", through ",
                                                                                 "] Serving ",
                                                                                 "::"],
                                                                               &match (&self_combox,
                                                                                       &self_vtable,
                                                                                       &"Foo",
                                                                                       &"simple_method")
                                                                                    {
                                                                                    (arg0,
                                                                                     arg1,
                                                                                     arg2,
                                                                                     arg3)
                                                                                    =>
                                                                                    [::core::fmt::ArgumentV1::new(arg0,
                                                                                                                  ::core::fmt::Pointer::fmt),
                                                                                     ::core::fmt::ArgumentV1::new(arg1,
                                                                                                                  ::core::fmt::Pointer::fmt),
                                                                                     ::core::fmt::ArgumentV1::new(arg2,
                                                                                                                  ::core::fmt::Display::fmt),
                                                                                     ::core::fmt::ArgumentV1::new(arg3,
                                                                                                                  ::core::fmt::Display::fmt)],
                                                                                })));
                 let self_struct: &Foo = &**self_combox;
                 let __result = self_struct.simple_method();
                 Ok({ })
             })();
    use intercom::ErrorValue;
    match result {
        Ok(v) => {
            intercom::logging::trace(|l| {
                l(
                    "testcrate",
                    ::core::fmt::Arguments::new_v1(
                        &["[", ", through ", "] Serving ", "::", ", OK"],
                        &match (&self_combox, &self_vtable, &"Foo", &"simple_method") {
                            (arg0, arg1, arg2, arg3) => [
                                ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Pointer::fmt),
                                ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Pointer::fmt),
                                ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                                ::core::fmt::ArgumentV1::new(arg3, ::core::fmt::Display::fmt),
                            ],
                        },
                    ),
                )
            });
            v
        }
        Err(err) => {
            intercom::logging::trace(|l| {
                l(
                    "testcrate",
                    ::core::fmt::Arguments::new_v1(
                        &["[", ", through ", "] Serving ", "::", ", ERROR"],
                        &match (&self_combox, &self_vtable, &"Foo", &"simple_method") {
                            (arg0, arg1, arg2, arg3) => [
                                ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Pointer::fmt),
                                ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Pointer::fmt),
                                ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                                ::core::fmt::ArgumentV1::new(arg3, ::core::fmt::Display::fmt),
                            ],
                        },
                    ),
                )
            });
            <<() as
             intercom::type_system::ExternType<intercom::type_system::AutomationTypeSystem>>::ExternOutputType
                as ErrorValue>::from_error(intercom::store_error(err))
        }
    }
}
#[allow(non_snake_case)]
#[allow(dead_code)]
#[doc(hidden)]
unsafe extern "system" fn __Foo_Foo_Automation_arg_method_Automation(self_vtable:
                                                                         intercom::RawComPtr,
                                                                     a:
                                                                         <u16
                                                                         as
                                                                         intercom::type_system::ExternType<intercom::type_system::AutomationTypeSystem>>::ExternInputType)
 ->
     <() as
intercom::type_system::ExternType<intercom::type_system::AutomationTypeSystem>>::ExternOutputType{
    let self_combox = (self_vtable as usize
        - <Foo as intercom::attributes::ComClass<
            Foo,
            intercom::type_system::AutomationTypeSystem,
        >>::offset()) as *mut intercom::ComBoxData<Foo>;
    use intercom::type_system::{IntercomFrom, IntercomInto};
    let result:
            Result<<() as
                   intercom::type_system::ExternType<intercom::type_system::AutomationTypeSystem>>::ExternOutputType,
                   intercom::ComError> =
        (||
             {
                 intercom::logging::trace(|l|
                                              l("testcrate",
                                                ::core::fmt::Arguments::new_v1(&["[",
                                                                                 ", through ",
                                                                                 "] Serving ",
                                                                                 "::"],
                                                                               &match (&self_combox,
                                                                                       &self_vtable,
                                                                                       &"Foo",
                                                                                       &"arg_method")
                                                                                    {
                                                                                    (arg0,
                                                                                     arg1,
                                                                                     arg2,
                                                                                     arg3)
                                                                                    =>
                                                                                    [::core::fmt::ArgumentV1::new(arg0,
                                                                                                                  ::core::fmt::Pointer::fmt),
                                                                                     ::core::fmt::ArgumentV1::new(arg1,
                                                                                                                  ::core::fmt::Pointer::fmt),
                                                                                     ::core::fmt::ArgumentV1::new(arg2,
                                                                                                                  ::core::fmt::Display::fmt),
                                                                                     ::core::fmt::ArgumentV1::new(arg3,
                                                                                                                  ::core::fmt::Display::fmt)],
                                                                                })));
                 let self_struct: &Foo = &**self_combox;
                 let __result =
                     self_struct.arg_method((<u16 as
                                                 intercom::type_system::ExternType<intercom::type_system::AutomationTypeSystem>>::intercom_from(a)?).intercom_into()?);
                 Ok({ })
             })();
    use intercom::ErrorValue;
    match result {
        Ok(v) => {
            intercom::logging::trace(|l| {
                l(
                    "testcrate",
                    ::core::fmt::Arguments::new_v1(
                        &["[", ", through ", "] Serving ", "::", ", OK"],
                        &match (&self_combox, &self_vtable, &"Foo", &"arg_method") {
                            (arg0, arg1, arg2, arg3) => [
                                ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Pointer::fmt),
                                ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Pointer::fmt),
                                ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                                ::core::fmt::ArgumentV1::new(arg3, ::core::fmt::Display::fmt),
                            ],
                        },
                    ),
                )
            });
            v
        }
        Err(err) => {
            intercom::logging::trace(|l| {
                l(
                    "testcrate",
                    ::core::fmt::Arguments::new_v1(
                        &["[", ", through ", "] Serving ", "::", ", ERROR"],
                        &match (&self_combox, &self_vtable, &"Foo", &"arg_method") {
                            (arg0, arg1, arg2, arg3) => [
                                ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Pointer::fmt),
                                ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Pointer::fmt),
                                ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                                ::core::fmt::ArgumentV1::new(arg3, ::core::fmt::Display::fmt),
                            ],
                        },
                    ),
                )
            });
            <<() as
             intercom::type_system::ExternType<intercom::type_system::AutomationTypeSystem>>::ExternOutputType
                as ErrorValue>::from_error(intercom::store_error(err))
        }
    }
}
#[allow(non_snake_case)]
#[allow(dead_code)]
#[doc(hidden)]
unsafe extern "system" fn __Foo_Foo_Automation_simple_result_method_Automation(self_vtable:
                                                                                   intercom::RawComPtr)
 ->
     <u16 as
intercom::type_system::ExternType<intercom::type_system::AutomationTypeSystem>>::ExternOutputType{
    let self_combox = (self_vtable as usize
        - <Foo as intercom::attributes::ComClass<
            Foo,
            intercom::type_system::AutomationTypeSystem,
        >>::offset()) as *mut intercom::ComBoxData<Foo>;
    use intercom::type_system::{IntercomFrom, IntercomInto};
    let result:
            Result<<u16 as
                   intercom::type_system::ExternType<intercom::type_system::AutomationTypeSystem>>::ExternOutputType,
                   intercom::ComError> =
        (||
             {
                 intercom::logging::trace(|l|
                                              l("testcrate",
                                                ::core::fmt::Arguments::new_v1(&["[",
                                                                                 ", through ",
                                                                                 "] Serving ",
                                                                                 "::"],
                                                                               &match (&self_combox,
                                                                                       &self_vtable,
                                                                                       &"Foo",
                                                                                       &"simple_result_method")
                                                                                    {
                                                                                    (arg0,
                                                                                     arg1,
                                                                                     arg2,
                                                                                     arg3)
                                                                                    =>
                                                                                    [::core::fmt::ArgumentV1::new(arg0,
                                                                                                                  ::core::fmt::Pointer::fmt),
                                                                                     ::core::fmt::ArgumentV1::new(arg1,
                                                                                                                  ::core::fmt::Pointer::fmt),
                                                                                     ::core::fmt::ArgumentV1::new(arg2,
                                                                                                                  ::core::fmt::Display::fmt),
                                                                                     ::core::fmt::ArgumentV1::new(arg3,
                                                                                                                  ::core::fmt::Display::fmt)],
                                                                                })));
                 let self_struct: &Foo = &**self_combox;
                 let __result = self_struct.simple_result_method();
                 Ok({ __result.intercom_into()? })
             })();
    use intercom::ErrorValue;
    match result {
        Ok(v) => {
            intercom::logging::trace(|l| {
                l(
                    "testcrate",
                    ::core::fmt::Arguments::new_v1(
                        &["[", ", through ", "] Serving ", "::", ", OK"],
                        &match (&self_combox, &self_vtable, &"Foo", &"simple_result_method") {
                            (arg0, arg1, arg2, arg3) => [
                                ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Pointer::fmt),
                                ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Pointer::fmt),
                                ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                                ::core::fmt::ArgumentV1::new(arg3, ::core::fmt::Display::fmt),
                            ],
                        },
                    ),
                )
            });
            v
        }
        Err(err) => {
            intercom::logging::trace(|l| {
                l(
                    "testcrate",
                    ::core::fmt::Arguments::new_v1(
                        &["[", ", through ", "] Serving ", "::", ", ERROR"],
                        &match (&self_combox, &self_vtable, &"Foo", &"simple_result_method") {
                            (arg0, arg1, arg2, arg3) => [
                                ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Pointer::fmt),
                                ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Pointer::fmt),
                                ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                                ::core::fmt::ArgumentV1::new(arg3, ::core::fmt::Display::fmt),
                            ],
                        },
                    ),
                )
            });
            <<u16 as intercom::type_system::ExternType<
                intercom::type_system::AutomationTypeSystem,
            >>::ExternOutputType as ErrorValue>::from_error(intercom::store_error(err))
        }
    }
}
#[allow(non_snake_case)]
#[allow(dead_code)]
#[doc(hidden)]
unsafe extern "system" fn __Foo_Foo_Automation_com_result_method_Automation(
    self_vtable: intercom::RawComPtr,
    __out: *mut <u16 as intercom::type_system::ExternType<
        intercom::type_system::AutomationTypeSystem,
    >>::ExternOutputType,
) -> <intercom::raw::HRESULT as intercom::type_system::ExternType<
    intercom::type_system::AutomationTypeSystem,
>>::ExternOutputType {
    let self_combox = (self_vtable as usize
        - <Foo as intercom::attributes::ComClass<
            Foo,
            intercom::type_system::AutomationTypeSystem,
        >>::offset()) as *mut intercom::ComBoxData<Foo>;
    use intercom::type_system::{IntercomFrom, IntercomInto};
    let result: Result<
        <intercom::raw::HRESULT as intercom::type_system::ExternType<
            intercom::type_system::AutomationTypeSystem,
        >>::ExternOutputType,
        intercom::ComError,
    > = (|| {
        intercom::logging::trace(|l| {
            l(
                "testcrate",
                ::core::fmt::Arguments::new_v1(
                    &["[", ", through ", "] Serving ", "::"],
                    &match (&self_combox, &self_vtable, &"Foo", &"com_result_method") {
                        (arg0, arg1, arg2, arg3) => [
                            ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Pointer::fmt),
                            ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Pointer::fmt),
                            ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                            ::core::fmt::ArgumentV1::new(arg3, ::core::fmt::Display::fmt),
                        ],
                    },
                ),
            )
        });
        let self_struct: &Foo = &**self_combox;
        let __result = self_struct.com_result_method();
        Ok({
            match __result {
                Ok(v1) => {
                    *__out = v1.intercom_into()?;
                    intercom::raw::S_OK
                }
                Err(e) => {
                    *__out = intercom::type_system::ExternDefault::extern_default();
                    intercom::store_error(e).hresult
                }
            }
        })
    })();
    use intercom::ErrorValue;
    match result {
        Ok(v) => {
            intercom::logging::trace(|l| {
                l(
                    "testcrate",
                    ::core::fmt::Arguments::new_v1(
                        &["[", ", through ", "] Serving ", "::", ", OK"],
                        &match (&self_combox, &self_vtable, &"Foo", &"com_result_method") {
                            (arg0, arg1, arg2, arg3) => [
                                ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Pointer::fmt),
                                ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Pointer::fmt),
                                ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                                ::core::fmt::ArgumentV1::new(arg3, ::core::fmt::Display::fmt),
                            ],
                        },
                    ),
                )
            });
            v
        }
        Err(err) => {
            intercom::logging::trace(|l| {
                l(
                    "testcrate",
                    ::core::fmt::Arguments::new_v1(
                        &["[", ", through ", "] Serving ", "::", ", ERROR"],
                        &match (&self_combox, &self_vtable, &"Foo", &"com_result_method") {
                            (arg0, arg1, arg2, arg3) => [
                                ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Pointer::fmt),
                                ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Pointer::fmt),
                                ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                                ::core::fmt::ArgumentV1::new(arg3, ::core::fmt::Display::fmt),
                            ],
                        },
                    ),
                )
            });
            <<intercom::raw::HRESULT as intercom::type_system::ExternType<
                intercom::type_system::AutomationTypeSystem,
            >>::ExternOutputType as ErrorValue>::from_error(intercom::store_error(err))
        }
    }
}
#[allow(non_snake_case)]
#[allow(dead_code)]
#[doc(hidden)]
unsafe extern "system" fn __Foo_Foo_Automation_rust_result_method_Automation(
    self_vtable: intercom::RawComPtr,
    __out: *mut <u16 as intercom::type_system::ExternType<
        intercom::type_system::AutomationTypeSystem,
    >>::ExternOutputType,
) -> <intercom::raw::HRESULT as intercom::type_system::ExternType<
    intercom::type_system::AutomationTypeSystem,
>>::ExternOutputType {
    let self_combox = (self_vtable as usize
        - <Foo as intercom::attributes::ComClass<
            Foo,
            intercom::type_system::AutomationTypeSystem,
        >>::offset()) as *mut intercom::ComBoxData<Foo>;
    use intercom::type_system::{IntercomFrom, IntercomInto};
    let result: Result<
        <intercom::raw::HRESULT as intercom::type_system::ExternType<
            intercom::type_system::AutomationTypeSystem,
        >>::ExternOutputType,
        intercom::ComError,
    > = (|| {
        intercom::logging::trace(|l| {
            l(
                "testcrate",
                ::core::fmt::Arguments::new_v1(
                    &["[", ", through ", "] Serving ", "::"],
                    &match (&self_combox, &self_vtable, &"Foo", &"rust_result_method") {
                        (arg0, arg1, arg2, arg3) => [
                            ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Pointer::fmt),
                            ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Pointer::fmt),
                            ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                            ::core::fmt::ArgumentV1::new(arg3, ::core::fmt::Display::fmt),
                        ],
                    },
                ),
            )
        });
        let self_struct: &Foo = &**self_combox;
        let __result = self_struct.rust_result_method();
        Ok({
            match __result {
                Ok(v1) => {
                    *__out = v1.intercom_into()?;
                    intercom::raw::S_OK
                }
                Err(e) => {
                    *__out = intercom::type_system::ExternDefault::extern_default();
                    intercom::store_error(e).hresult
                }
            }
        })
    })();
    use intercom::ErrorValue;
    match result {
        Ok(v) => {
            intercom::logging::trace(|l| {
                l(
                    "testcrate",
                    ::core::fmt::Arguments::new_v1(
                        &["[", ", through ", "] Serving ", "::", ", OK"],
                        &match (&self_combox, &self_vtable, &"Foo", &"rust_result_method") {
                            (arg0, arg1, arg2, arg3) => [
                                ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Pointer::fmt),
                                ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Pointer::fmt),
                                ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                                ::core::fmt::ArgumentV1::new(arg3, ::core::fmt::Display::fmt),
                            ],
                        },
                    ),
                )
            });
            v
        }
        Err(err) => {
            intercom::logging::trace(|l| {
                l(
                    "testcrate",
                    ::core::fmt::Arguments::new_v1(
                        &["[", ", through ", "] Serving ", "::", ", ERROR"],
                        &match (&self_combox, &self_vtable, &"Foo", &"rust_result_method") {
                            (arg0, arg1, arg2, arg3) => [
                                ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Pointer::fmt),
                                ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Pointer::fmt),
                                ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                                ::core::fmt::ArgumentV1::new(arg3, ::core::fmt::Display::fmt),
                            ],
                        },
                    ),
                )
            });
            <<intercom::raw::HRESULT as intercom::type_system::ExternType<
                intercom::type_system::AutomationTypeSystem,
            >>::ExternOutputType as ErrorValue>::from_error(intercom::store_error(err))
        }
    }
}
#[allow(non_snake_case)]
#[allow(dead_code)]
#[doc(hidden)]
unsafe extern "system" fn __Foo_Foo_Automation_tuple_result_method_Automation(
    self_vtable: intercom::RawComPtr,
    __out1: *mut <u8 as intercom::type_system::ExternType<
        intercom::type_system::AutomationTypeSystem,
    >>::ExternOutputType,
    __out2: *mut <u16 as intercom::type_system::ExternType<
        intercom::type_system::AutomationTypeSystem,
    >>::ExternOutputType,
    __out3: *mut <u32 as intercom::type_system::ExternType<
        intercom::type_system::AutomationTypeSystem,
    >>::ExternOutputType,
) -> <intercom::raw::HRESULT as intercom::type_system::ExternType<
    intercom::type_system::AutomationTypeSystem,
>>::ExternOutputType {
    let self_combox = (self_vtable as usize
        - <Foo as intercom::attributes::ComClass<
            Foo,
            intercom::type_system::AutomationTypeSystem,
        >>::offset()) as *mut intercom::ComBoxData<Foo>;
    use intercom::type_system::{IntercomFrom, IntercomInto};
    let result: Result<
        <intercom::raw::HRESULT as intercom::type_system::ExternType<
            intercom::type_system::AutomationTypeSystem,
        >>::ExternOutputType,
        intercom::ComError,
    > = (|| {
        intercom::logging::trace(|l| {
            l(
                "testcrate",
                ::core::fmt::Arguments::new_v1(
                    &["[", ", through ", "] Serving ", "::"],
                    &match (&self_combox, &self_vtable, &"Foo", &"tuple_result_method") {
                        (arg0, arg1, arg2, arg3) => [
                            ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Pointer::fmt),
                            ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Pointer::fmt),
                            ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                            ::core::fmt::ArgumentV1::new(arg3, ::core::fmt::Display::fmt),
                        ],
                    },
                ),
            )
        });
        let self_struct: &Foo = &**self_combox;
        let __result = self_struct.tuple_result_method();
        Ok({
            match __result {
                Ok((v1, v2, v3)) => {
                    *__out1 = v1.intercom_into()?;
                    *__out2 = v2.intercom_into()?;
                    *__out3 = v3.intercom_into()?;
                    intercom::raw::S_OK
                }
                Err(e) => {
                    *__out1 = intercom::type_system::ExternDefault::extern_default();
                    *__out2 = intercom::type_system::ExternDefault::extern_default();
                    *__out3 = intercom::type_system::ExternDefault::extern_default();
                    intercom::store_error(e).hresult
                }
            }
        })
    })();
    use intercom::ErrorValue;
    match result {
        Ok(v) => {
            intercom::logging::trace(|l| {
                l(
                    "testcrate",
                    ::core::fmt::Arguments::new_v1(
                        &["[", ", through ", "] Serving ", "::", ", OK"],
                        &match (&self_combox, &self_vtable, &"Foo", &"tuple_result_method") {
                            (arg0, arg1, arg2, arg3) => [
                                ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Pointer::fmt),
                                ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Pointer::fmt),
                                ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                                ::core::fmt::ArgumentV1::new(arg3, ::core::fmt::Display::fmt),
                            ],
                        },
                    ),
                )
            });
            v
        }
        Err(err) => {
            intercom::logging::trace(|l| {
                l(
                    "testcrate",
                    ::core::fmt::Arguments::new_v1(
                        &["[", ", through ", "] Serving ", "::", ", ERROR"],
                        &match (&self_combox, &self_vtable, &"Foo", &"tuple_result_method") {
                            (arg0, arg1, arg2, arg3) => [
                                ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Pointer::fmt),
                                ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Pointer::fmt),
                                ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                                ::core::fmt::ArgumentV1::new(arg3, ::core::fmt::Display::fmt),
                            ],
                        },
                    ),
                )
            });
            <<intercom::raw::HRESULT as intercom::type_system::ExternType<
                intercom::type_system::AutomationTypeSystem,
            >>::ExternOutputType as ErrorValue>::from_error(intercom::store_error(err))
        }
    }
}
#[allow(non_snake_case)]
#[allow(dead_code)]
#[doc(hidden)]
unsafe extern "system" fn __Foo_Foo_Automation_string_method_Automation(self_vtable:
                                                                            intercom::RawComPtr,
                                                                        input:
                                                                            <String
                                                                            as
                                                                            intercom::type_system::ExternType<intercom::type_system::AutomationTypeSystem>>::ExternInputType)
 ->
     <String as
intercom::type_system::ExternType<intercom::type_system::AutomationTypeSystem>>::ExternOutputType{
    let self_combox = (self_vtable as usize
        - <Foo as intercom::attributes::ComClass<
            Foo,
            intercom::type_system::AutomationTypeSystem,
        >>::offset()) as *mut intercom::ComBoxData<Foo>;
    use intercom::type_system::{IntercomFrom, IntercomInto};
    let result: Result<
        <String as intercom::type_system::ExternType<
            intercom::type_system::AutomationTypeSystem,
        >>::ExternOutputType,
        intercom::ComError,
    > = (|| {
        intercom::logging::trace(|l| {
            l(
                "testcrate",
                ::core::fmt::Arguments::new_v1(
                    &["[", ", through ", "] Serving ", "::"],
                    &match (&self_combox, &self_vtable, &"Foo", &"string_method") {
                        (arg0, arg1, arg2, arg3) => [
                            ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Pointer::fmt),
                            ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Pointer::fmt),
                            ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                            ::core::fmt::ArgumentV1::new(arg3, ::core::fmt::Display::fmt),
                        ],
                    },
                ),
            )
        });
        let self_struct: &Foo = &**self_combox;
        let __result = self_struct.string_method(
            (<String as intercom::type_system::ExternType<
                intercom::type_system::AutomationTypeSystem,
            >>::intercom_from(input)?)
            .intercom_into()?,
        );
        Ok({ __result.intercom_into()? })
    })();
    use intercom::ErrorValue;
    match result {
        Ok(v) => {
            intercom::logging::trace(|l| {
                l(
                    "testcrate",
                    ::core::fmt::Arguments::new_v1(
                        &["[", ", through ", "] Serving ", "::", ", OK"],
                        &match (&self_combox, &self_vtable, &"Foo", &"string_method") {
                            (arg0, arg1, arg2, arg3) => [
                                ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Pointer::fmt),
                                ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Pointer::fmt),
                                ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                                ::core::fmt::ArgumentV1::new(arg3, ::core::fmt::Display::fmt),
                            ],
                        },
                    ),
                )
            });
            v
        }
        Err(err) => {
            intercom::logging::trace(|l| {
                l(
                    "testcrate",
                    ::core::fmt::Arguments::new_v1(
                        &["[", ", through ", "] Serving ", "::", ", ERROR"],
                        &match (&self_combox, &self_vtable, &"Foo", &"string_method") {
                            (arg0, arg1, arg2, arg3) => [
                                ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Pointer::fmt),
                                ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Pointer::fmt),
                                ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                                ::core::fmt::ArgumentV1::new(arg3, ::core::fmt::Display::fmt),
                            ],
                        },
                    ),
                )
            });
            <<String as intercom::type_system::ExternType<
                intercom::type_system::AutomationTypeSystem,
            >>::ExternOutputType as ErrorValue>::from_error(intercom::store_error(err))
        }
    }
}
#[allow(non_snake_case)]
#[allow(dead_code)]
#[doc(hidden)]
unsafe extern "system" fn __Foo_Foo_Automation_string_result_method_Automation(
    self_vtable: intercom::RawComPtr,
    input: <String as intercom::type_system::ExternType<
        intercom::type_system::AutomationTypeSystem,
    >>::ExternInputType,
    __out: *mut <String as intercom::type_system::ExternType<
        intercom::type_system::AutomationTypeSystem,
    >>::ExternOutputType,
) -> <intercom::raw::HRESULT as intercom::type_system::ExternType<
    intercom::type_system::AutomationTypeSystem,
>>::ExternOutputType {
    let self_combox = (self_vtable as usize
        - <Foo as intercom::attributes::ComClass<
            Foo,
            intercom::type_system::AutomationTypeSystem,
        >>::offset()) as *mut intercom::ComBoxData<Foo>;
    use intercom::type_system::{IntercomFrom, IntercomInto};
    let result: Result<
        <intercom::raw::HRESULT as intercom::type_system::ExternType<
            intercom::type_system::AutomationTypeSystem,
        >>::ExternOutputType,
        intercom::ComError,
    > = (|| {
        intercom::logging::trace(|l| {
            l(
                "testcrate",
                ::core::fmt::Arguments::new_v1(
                    &["[", ", through ", "] Serving ", "::"],
                    &match (&self_combox, &self_vtable, &"Foo", &"string_result_method") {
                        (arg0, arg1, arg2, arg3) => [
                            ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Pointer::fmt),
                            ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Pointer::fmt),
                            ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                            ::core::fmt::ArgumentV1::new(arg3, ::core::fmt::Display::fmt),
                        ],
                    },
                ),
            )
        });
        let self_struct: &Foo = &**self_combox;
        let __result = self_struct.string_result_method(
            (<String as intercom::type_system::ExternType<
                intercom::type_system::AutomationTypeSystem,
            >>::intercom_from(input)?)
            .intercom_into()?,
        );
        Ok({
            match __result {
                Ok(v1) => {
                    *__out = v1.intercom_into()?;
                    intercom::raw::S_OK
                }
                Err(e) => {
                    *__out = intercom::type_system::ExternDefault::extern_default();
                    intercom::store_error(e).hresult
                }
            }
        })
    })();
    use intercom::ErrorValue;
    match result {
        Ok(v) => {
            intercom::logging::trace(|l| {
                l(
                    "testcrate",
                    ::core::fmt::Arguments::new_v1(
                        &["[", ", through ", "] Serving ", "::", ", OK"],
                        &match (&self_combox, &self_vtable, &"Foo", &"string_result_method") {
                            (arg0, arg1, arg2, arg3) => [
                                ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Pointer::fmt),
                                ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Pointer::fmt),
                                ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                                ::core::fmt::ArgumentV1::new(arg3, ::core::fmt::Display::fmt),
                            ],
                        },
                    ),
                )
            });
            v
        }
        Err(err) => {
            intercom::logging::trace(|l| {
                l(
                    "testcrate",
                    ::core::fmt::Arguments::new_v1(
                        &["[", ", through ", "] Serving ", "::", ", ERROR"],
                        &match (&self_combox, &self_vtable, &"Foo", &"string_result_method") {
                            (arg0, arg1, arg2, arg3) => [
                                ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Pointer::fmt),
                                ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Pointer::fmt),
                                ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                                ::core::fmt::ArgumentV1::new(arg3, ::core::fmt::Display::fmt),
                            ],
                        },
                    ),
                )
            });
            <<intercom::raw::HRESULT as intercom::type_system::ExternType<
                intercom::type_system::AutomationTypeSystem,
            >>::ExternOutputType as ErrorValue>::from_error(intercom::store_error(err))
        }
    }
}
#[allow(non_snake_case)]
#[allow(dead_code)]
#[doc(hidden)]
unsafe extern "system" fn __Foo_Foo_Automation_complete_method_Automation(
    self_vtable: intercom::RawComPtr,
    a:
                                                                              <u16
                                                                              as
                                                                              intercom::type_system::ExternType<intercom::type_system::AutomationTypeSystem>>::ExternInputType,
    b:
                                                                              <i16
                                                                              as
                                                                              intercom::type_system::ExternType<intercom::type_system::AutomationTypeSystem>>::ExternInputType,
    __out: *mut <bool as intercom::type_system::ExternType<
        intercom::type_system::AutomationTypeSystem,
    >>::ExternOutputType,
) -> <intercom::raw::HRESULT as intercom::type_system::ExternType<
    intercom::type_system::AutomationTypeSystem,
>>::ExternOutputType {
    let self_combox = (self_vtable as usize
        - <Foo as intercom::attributes::ComClass<
            Foo,
            intercom::type_system::AutomationTypeSystem,
        >>::offset()) as *mut intercom::ComBoxData<Foo>;
    use intercom::type_system::{IntercomFrom, IntercomInto};
    let result: Result<
        <intercom::raw::HRESULT as intercom::type_system::ExternType<
            intercom::type_system::AutomationTypeSystem,
        >>::ExternOutputType,
        intercom::ComError,
    > = (|| {
        intercom::logging::trace(|l| {
            l(
                "testcrate",
                ::core::fmt::Arguments::new_v1(
                    &["[", ", through ", "] Serving ", "::"],
                    &match (&self_combox, &self_vtable, &"Foo", &"complete_method") {
                        (arg0, arg1, arg2, arg3) => [
                            ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Pointer::fmt),
                            ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Pointer::fmt),
                            ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                            ::core::fmt::ArgumentV1::new(arg3, ::core::fmt::Display::fmt),
                        ],
                    },
                ),
            )
        });
        let self_struct: &mut Foo = &mut **self_combox;
        let __result = self_struct.complete_method(
            (<u16 as intercom::type_system::ExternType<
                intercom::type_system::AutomationTypeSystem,
            >>::intercom_from(a)?)
            .intercom_into()?,
            (<i16 as intercom::type_system::ExternType<
                intercom::type_system::AutomationTypeSystem,
            >>::intercom_from(b)?)
            .intercom_into()?,
        );
        Ok({
            match __result {
                Ok(v1) => {
                    *__out = v1.intercom_into()?;
                    intercom::raw::S_OK
                }
                Err(e) => {
                    *__out = intercom::type_system::ExternDefault::extern_default();
                    intercom::store_error(e).hresult
                }
            }
        })
    })();
    use intercom::ErrorValue;
    match result {
        Ok(v) => {
            intercom::logging::trace(|l| {
                l(
                    "testcrate",
                    ::core::fmt::Arguments::new_v1(
                        &["[", ", through ", "] Serving ", "::", ", OK"],
                        &match (&self_combox, &self_vtable, &"Foo", &"complete_method") {
                            (arg0, arg1, arg2, arg3) => [
                                ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Pointer::fmt),
                                ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Pointer::fmt),
                                ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                                ::core::fmt::ArgumentV1::new(arg3, ::core::fmt::Display::fmt),
                            ],
                        },
                    ),
                )
            });
            v
        }
        Err(err) => {
            intercom::logging::trace(|l| {
                l(
                    "testcrate",
                    ::core::fmt::Arguments::new_v1(
                        &["[", ", through ", "] Serving ", "::", ", ERROR"],
                        &match (&self_combox, &self_vtable, &"Foo", &"complete_method") {
                            (arg0, arg1, arg2, arg3) => [
                                ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Pointer::fmt),
                                ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Pointer::fmt),
                                ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                                ::core::fmt::ArgumentV1::new(arg3, ::core::fmt::Display::fmt),
                            ],
                        },
                    ),
                )
            });
            <<intercom::raw::HRESULT as intercom::type_system::ExternType<
                intercom::type_system::AutomationTypeSystem,
            >>::ExternOutputType as ErrorValue>::from_error(intercom::store_error(err))
        }
    }
}
#[allow(non_snake_case)]
#[allow(dead_code)]
#[doc(hidden)]
unsafe extern "system" fn __Foo_Foo_Automation_bool_method_Automation(
    self_vtable: intercom::RawComPtr,
    input: <bool as intercom::type_system::ExternType<
        intercom::type_system::AutomationTypeSystem,
    >>::ExternInputType,
    __out: *mut <bool as intercom::type_system::ExternType<
        intercom::type_system::AutomationTypeSystem,
    >>::ExternOutputType,
) -> <intercom::raw::HRESULT as intercom::type_system::ExternType<
    intercom::type_system::AutomationTypeSystem,
>>::ExternOutputType {
    let self_combox = (self_vtable as usize
        - <Foo as intercom::attributes::ComClass<
            Foo,
            intercom::type_system::AutomationTypeSystem,
        >>::offset()) as *mut intercom::ComBoxData<Foo>;
    use intercom::type_system::{IntercomFrom, IntercomInto};
    let result: Result<
        <intercom::raw::HRESULT as intercom::type_system::ExternType<
            intercom::type_system::AutomationTypeSystem,
        >>::ExternOutputType,
        intercom::ComError,
    > = (|| {
        intercom::logging::trace(|l| {
            l(
                "testcrate",
                ::core::fmt::Arguments::new_v1(
                    &["[", ", through ", "] Serving ", "::"],
                    &match (&self_combox, &self_vtable, &"Foo", &"bool_method") {
                        (arg0, arg1, arg2, arg3) => [
                            ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Pointer::fmt),
                            ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Pointer::fmt),
                            ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                            ::core::fmt::ArgumentV1::new(arg3, ::core::fmt::Display::fmt),
                        ],
                    },
                ),
            )
        });
        let self_struct: &Foo = &**self_combox;
        let __result = self_struct.bool_method(
            (<bool as intercom::type_system::ExternType<
                intercom::type_system::AutomationTypeSystem,
            >>::intercom_from(input)?)
            .intercom_into()?,
        );
        Ok({
            match __result {
                Ok(v1) => {
                    *__out = v1.intercom_into()?;
                    intercom::raw::S_OK
                }
                Err(e) => {
                    *__out = intercom::type_system::ExternDefault::extern_default();
                    intercom::store_error(e).hresult
                }
            }
        })
    })();
    use intercom::ErrorValue;
    match result {
        Ok(v) => {
            intercom::logging::trace(|l| {
                l(
                    "testcrate",
                    ::core::fmt::Arguments::new_v1(
                        &["[", ", through ", "] Serving ", "::", ", OK"],
                        &match (&self_combox, &self_vtable, &"Foo", &"bool_method") {
                            (arg0, arg1, arg2, arg3) => [
                                ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Pointer::fmt),
                                ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Pointer::fmt),
                                ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                                ::core::fmt::ArgumentV1::new(arg3, ::core::fmt::Display::fmt),
                            ],
                        },
                    ),
                )
            });
            v
        }
        Err(err) => {
            intercom::logging::trace(|l| {
                l(
                    "testcrate",
                    ::core::fmt::Arguments::new_v1(
                        &["[", ", through ", "] Serving ", "::", ", ERROR"],
                        &match (&self_combox, &self_vtable, &"Foo", &"bool_method") {
                            (arg0, arg1, arg2, arg3) => [
                                ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Pointer::fmt),
                                ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Pointer::fmt),
                                ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                                ::core::fmt::ArgumentV1::new(arg3, ::core::fmt::Display::fmt),
                            ],
                        },
                    ),
                )
            });
            <<intercom::raw::HRESULT as intercom::type_system::ExternType<
                intercom::type_system::AutomationTypeSystem,
            >>::ExternOutputType as ErrorValue>::from_error(intercom::store_error(err))
        }
    }
}
#[allow(non_snake_case)]
#[allow(dead_code)]
#[doc(hidden)]
unsafe extern "system" fn __Foo_Foo_Automation_variant_method_Automation(
    self_vtable: intercom::RawComPtr,
    input: <Variant as intercom::type_system::ExternType<
        intercom::type_system::AutomationTypeSystem,
    >>::ExternInputType,
    __out: *mut <Variant as intercom::type_system::ExternType<
        intercom::type_system::AutomationTypeSystem,
    >>::ExternOutputType,
) -> <intercom::raw::HRESULT as intercom::type_system::ExternType<
    intercom::type_system::AutomationTypeSystem,
>>::ExternOutputType {
    let self_combox = (self_vtable as usize
        - <Foo as intercom::attributes::ComClass<
            Foo,
            intercom::type_system::AutomationTypeSystem,
        >>::offset()) as *mut intercom::ComBoxData<Foo>;
    use intercom::type_system::{IntercomFrom, IntercomInto};
    let result: Result<
        <intercom::raw::HRESULT as intercom::type_system::ExternType<
            intercom::type_system::AutomationTypeSystem,
        >>::ExternOutputType,
        intercom::ComError,
    > = (|| {
        intercom::logging::trace(|l| {
            l(
                "testcrate",
                ::core::fmt::Arguments::new_v1(
                    &["[", ", through ", "] Serving ", "::"],
                    &match (&self_combox, &self_vtable, &"Foo", &"variant_method") {
                        (arg0, arg1, arg2, arg3) => [
                            ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Pointer::fmt),
                            ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Pointer::fmt),
                            ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                            ::core::fmt::ArgumentV1::new(arg3, ::core::fmt::Display::fmt),
                        ],
                    },
                ),
            )
        });
        let self_struct: &Foo = &**self_combox;
        let __result = self_struct.variant_method(
            (<Variant as intercom::type_system::ExternType<
                intercom::type_system::AutomationTypeSystem,
            >>::intercom_from(input)?)
            .intercom_into()?,
        );
        Ok({
            match __result {
                Ok(v1) => {
                    *__out = v1.intercom_into()?;
                    intercom::raw::S_OK
                }
                Err(e) => {
                    *__out = intercom::type_system::ExternDefault::extern_default();
                    intercom::store_error(e).hresult
                }
            }
        })
    })();
    use intercom::ErrorValue;
    match result {
        Ok(v) => {
            intercom::logging::trace(|l| {
                l(
                    "testcrate",
                    ::core::fmt::Arguments::new_v1(
                        &["[", ", through ", "] Serving ", "::", ", OK"],
                        &match (&self_combox, &self_vtable, &"Foo", &"variant_method") {
                            (arg0, arg1, arg2, arg3) => [
                                ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Pointer::fmt),
                                ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Pointer::fmt),
                                ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                                ::core::fmt::ArgumentV1::new(arg3, ::core::fmt::Display::fmt),
                            ],
                        },
                    ),
                )
            });
            v
        }
        Err(err) => {
            intercom::logging::trace(|l| {
                l(
                    "testcrate",
                    ::core::fmt::Arguments::new_v1(
                        &["[", ", through ", "] Serving ", "::", ", ERROR"],
                        &match (&self_combox, &self_vtable, &"Foo", &"variant_method") {
                            (arg0, arg1, arg2, arg3) => [
                                ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Pointer::fmt),
                                ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Pointer::fmt),
                                ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                                ::core::fmt::ArgumentV1::new(arg3, ::core::fmt::Display::fmt),
                            ],
                        },
                    ),
                )
            });
            <<intercom::raw::HRESULT as intercom::type_system::ExternType<
                intercom::type_system::AutomationTypeSystem,
            >>::ExternOutputType as ErrorValue>::from_error(intercom::store_error(err))
        }
    }
}
#[allow(non_upper_case_globals)]
impl intercom::attributes::ComImpl<Foo, intercom::type_system::AutomationTypeSystem> for Foo {
    fn vtable() -> &'static <Foo as intercom::attributes::ComInterface<
        intercom::type_system::AutomationTypeSystem,
    >>::VTable {
        type T = <Foo as intercom::attributes::ComInterface<
            intercom::type_system::AutomationTypeSystem,
        >>::VTable;
        &T {
            __base: {
                type TVtbl = <dyn intercom::IUnknown as intercom::attributes::ComInterface<
                    intercom::type_system::AutomationTypeSystem,
                >>::VTable;
                TVtbl {
                    query_interface: __Foo_Foo_Automation_query_interface,
                    add_ref: __Foo_Foo_Automation_add_ref,
                    release: __Foo_Foo_Automation_release,
                }
            },
            simple_method: __Foo_Foo_Automation_simple_method_Automation,
            arg_method: __Foo_Foo_Automation_arg_method_Automation,
            simple_result_method: __Foo_Foo_Automation_simple_result_method_Automation,
            com_result_method: __Foo_Foo_Automation_com_result_method_Automation,
            rust_result_method: __Foo_Foo_Automation_rust_result_method_Automation,
            tuple_result_method: __Foo_Foo_Automation_tuple_result_method_Automation,
            string_method: __Foo_Foo_Automation_string_method_Automation,
            string_result_method: __Foo_Foo_Automation_string_result_method_Automation,
            complete_method: __Foo_Foo_Automation_complete_method_Automation,
            bool_method: __Foo_Foo_Automation_bool_method_Automation,
            variant_method: __Foo_Foo_Automation_variant_method_Automation,
        }
    }
}
#[allow(non_snake_case)]
#[doc(hidden)]
unsafe extern "system" fn __Foo_Foo_Raw_query_interface(
    self_vtable: intercom::RawComPtr,
    riid: <intercom::REFIID as intercom::type_system::ExternType<
        intercom::type_system::AutomationTypeSystem,
    >>::ExternInputType,
    out: *mut <intercom::RawComPtr as intercom::type_system::ExternType<
        intercom::type_system::AutomationTypeSystem,
    >>::ExternOutputType,
) -> <intercom::raw::HRESULT as intercom::type_system::ExternType<
    intercom::type_system::AutomationTypeSystem,
>>::ExternOutputType {
    let self_ptr =
        (self_vtable as usize -
             <Foo as
                 intercom::attributes::ComClass<Foo,
                                                intercom::type_system::RawTypeSystem>>::offset())
            as *mut _;
    intercom::logging::trace(|l| {
        l(
            "testcrate",
            ::core::fmt::Arguments::new_v1(
                &["[", ", through ", "] Serving ", "::query_interface"],
                &match (&self_ptr, &self_vtable, &"Foo") {
                    (arg0, arg1, arg2) => [
                        ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Pointer::fmt),
                        ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Pointer::fmt),
                        ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                    ],
                },
            ),
        )
    });
    intercom::ComBoxData::<Foo>::query_interface(&mut *self_ptr, riid, out)
}
#[allow(non_snake_case)]
#[allow(dead_code)]
#[doc(hidden)]
unsafe extern "system" fn __Foo_Foo_Raw_add_ref(self_vtable:
                                                    intercom::RawComPtr)
 ->
     <u32 as
intercom::type_system::ExternType<intercom::type_system::AutomationTypeSystem>>::ExternOutputType{
    let self_ptr =
        (self_vtable as usize -
             <Foo as
                 intercom::attributes::ComClass<Foo,
                                                intercom::type_system::RawTypeSystem>>::offset())
            as *mut _;
    intercom::logging::trace(|l| {
        l(
            "testcrate",
            ::core::fmt::Arguments::new_v1(
                &["[", ", through ", "] Serving ", "::add_ref"],
                &match (&self_ptr, &self_vtable, &"Foo") {
                    (arg0, arg1, arg2) => [
                        ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Pointer::fmt),
                        ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Pointer::fmt),
                        ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                    ],
                },
            ),
        )
    });
    intercom::ComBoxData::<Foo>::add_ref_ptr(self_ptr)
}
#[allow(non_snake_case)]
#[allow(dead_code)]
#[doc(hidden)]
unsafe extern "system" fn __Foo_Foo_Raw_release(self_vtable:
                                                    intercom::RawComPtr)
 ->
     <u32 as
intercom::type_system::ExternType<intercom::type_system::AutomationTypeSystem>>::ExternOutputType{
    let self_ptr =
        (self_vtable as usize -
             <Foo as
                 intercom::attributes::ComClass<Foo,
                                                intercom::type_system::RawTypeSystem>>::offset())
            as *mut _;
    intercom::logging::trace(|l| {
        l(
            "testcrate",
            ::core::fmt::Arguments::new_v1(
                &["[", ", through ", "] Serving ", "::release_ptr"],
                &match (&self_ptr, &self_vtable, &"Foo") {
                    (arg0, arg1, arg2) => [
                        ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Pointer::fmt),
                        ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Pointer::fmt),
                        ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                    ],
                },
            ),
        )
    });
    intercom::ComBoxData::<Foo>::release_ptr(self_ptr)
}
#[allow(non_snake_case)]
#[allow(dead_code)]
#[doc(hidden)]
unsafe extern "system" fn __Foo_Foo_Raw_simple_method_Raw(self_vtable:
                                                              intercom::RawComPtr)
 ->
     <() as
intercom::type_system::ExternType<intercom::type_system::AutomationTypeSystem>>::ExternOutputType{
    let self_combox =
        (self_vtable as usize -
             <Foo as
                 intercom::attributes::ComClass<Foo,
                                                intercom::type_system::RawTypeSystem>>::offset())
            as *mut intercom::ComBoxData<Foo>;
    use intercom::type_system::{IntercomFrom, IntercomInto};
    let result:
            Result<<() as
                   intercom::type_system::ExternType<intercom::type_system::AutomationTypeSystem>>::ExternOutputType,
                   intercom::ComError> =
        (||
             {
                 intercom::logging::trace(|l|
                                              l("testcrate",
                                                ::core::fmt::Arguments::new_v1(&["[",
                                                                                 ", through ",
                                                                                 "] Serving ",
                                                                                 "::"],
                                                                               &match (&self_combox,
                                                                                       &self_vtable,
                                                                                       &"Foo",
                                                                                       &"simple_method")
                                                                                    {
                                                                                    (arg0,
                                                                                     arg1,
                                                                                     arg2,
                                                                                     arg3)
                                                                                    =>
                                                                                    [::core::fmt::ArgumentV1::new(arg0,
                                                                                                                  ::core::fmt::Pointer::fmt),
                                                                                     ::core::fmt::ArgumentV1::new(arg1,
                                                                                                                  ::core::fmt::Pointer::fmt),
                                                                                     ::core::fmt::ArgumentV1::new(arg2,
                                                                                                                  ::core::fmt::Display::fmt),
                                                                                     ::core::fmt::ArgumentV1::new(arg3,
                                                                                                                  ::core::fmt::Display::fmt)],
                                                                                })));
                 let self_struct: &Foo = &**self_combox;
                 let __result = self_struct.simple_method();
                 Ok({ })
             })();
    use intercom::ErrorValue;
    match result {
        Ok(v) => {
            intercom::logging::trace(|l| {
                l(
                    "testcrate",
                    ::core::fmt::Arguments::new_v1(
                        &["[", ", through ", "] Serving ", "::", ", OK"],
                        &match (&self_combox, &self_vtable, &"Foo", &"simple_method") {
                            (arg0, arg1, arg2, arg3) => [
                                ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Pointer::fmt),
                                ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Pointer::fmt),
                                ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                                ::core::fmt::ArgumentV1::new(arg3, ::core::fmt::Display::fmt),
                            ],
                        },
                    ),
                )
            });
            v
        }
        Err(err) => {
            intercom::logging::trace(|l| {
                l(
                    "testcrate",
                    ::core::fmt::Arguments::new_v1(
                        &["[", ", through ", "] Serving ", "::", ", ERROR"],
                        &match (&self_combox, &self_vtable, &"Foo", &"simple_method") {
                            (arg0, arg1, arg2, arg3) => [
                                ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Pointer::fmt),
                                ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Pointer::fmt),
                                ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                                ::core::fmt::ArgumentV1::new(arg3, ::core::fmt::Display::fmt),
                            ],
                        },
                    ),
                )
            });
            <<() as
             intercom::type_system::ExternType<intercom::type_system::AutomationTypeSystem>>::ExternOutputType
                as ErrorValue>::from_error(intercom::store_error(err))
        }
    }
}
#[allow(non_snake_case)]
#[allow(dead_code)]
#[doc(hidden)]
unsafe extern "system" fn __Foo_Foo_Raw_arg_method_Raw(self_vtable:
                                                           intercom::RawComPtr,
                                                       a:
                                                           <u16 as
                                                           intercom::type_system::ExternType<intercom::type_system::RawTypeSystem>>::ExternInputType)
 ->
     <() as
intercom::type_system::ExternType<intercom::type_system::AutomationTypeSystem>>::ExternOutputType{
    let self_combox =
        (self_vtable as usize -
             <Foo as
                 intercom::attributes::ComClass<Foo,
                                                intercom::type_system::RawTypeSystem>>::offset())
            as *mut intercom::ComBoxData<Foo>;
    use intercom::type_system::{IntercomFrom, IntercomInto};
    let result:
            Result<<() as
                   intercom::type_system::ExternType<intercom::type_system::AutomationTypeSystem>>::ExternOutputType,
                   intercom::ComError> =
        (||
             {
                 intercom::logging::trace(|l|
                                              l("testcrate",
                                                ::core::fmt::Arguments::new_v1(&["[",
                                                                                 ", through ",
                                                                                 "] Serving ",
                                                                                 "::"],
                                                                               &match (&self_combox,
                                                                                       &self_vtable,
                                                                                       &"Foo",
                                                                                       &"arg_method")
                                                                                    {
                                                                                    (arg0,
                                                                                     arg1,
                                                                                     arg2,
                                                                                     arg3)
                                                                                    =>
                                                                                    [::core::fmt::ArgumentV1::new(arg0,
                                                                                                                  ::core::fmt::Pointer::fmt),
                                                                                     ::core::fmt::ArgumentV1::new(arg1,
                                                                                                                  ::core::fmt::Pointer::fmt),
                                                                                     ::core::fmt::ArgumentV1::new(arg2,
                                                                                                                  ::core::fmt::Display::fmt),
                                                                                     ::core::fmt::ArgumentV1::new(arg3,
                                                                                                                  ::core::fmt::Display::fmt)],
                                                                                })));
                 let self_struct: &Foo = &**self_combox;
                 let __result =
                     self_struct.arg_method((<u16 as
                                                 intercom::type_system::ExternType<intercom::type_system::RawTypeSystem>>::intercom_from(a)?).intercom_into()?);
                 Ok({ })
             })();
    use intercom::ErrorValue;
    match result {
        Ok(v) => {
            intercom::logging::trace(|l| {
                l(
                    "testcrate",
                    ::core::fmt::Arguments::new_v1(
                        &["[", ", through ", "] Serving ", "::", ", OK"],
                        &match (&self_combox, &self_vtable, &"Foo", &"arg_method") {
                            (arg0, arg1, arg2, arg3) => [
                                ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Pointer::fmt),
                                ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Pointer::fmt),
                                ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                                ::core::fmt::ArgumentV1::new(arg3, ::core::fmt::Display::fmt),
                            ],
                        },
                    ),
                )
            });
            v
        }
        Err(err) => {
            intercom::logging::trace(|l| {
                l(
                    "testcrate",
                    ::core::fmt::Arguments::new_v1(
                        &["[", ", through ", "] Serving ", "::", ", ERROR"],
                        &match (&self_combox, &self_vtable, &"Foo", &"arg_method") {
                            (arg0, arg1, arg2, arg3) => [
                                ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Pointer::fmt),
                                ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Pointer::fmt),
                                ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                                ::core::fmt::ArgumentV1::new(arg3, ::core::fmt::Display::fmt),
                            ],
                        },
                    ),
                )
            });
            <<() as
             intercom::type_system::ExternType<intercom::type_system::AutomationTypeSystem>>::ExternOutputType
                as ErrorValue>::from_error(intercom::store_error(err))
        }
    }
}
#[allow(non_snake_case)]
#[allow(dead_code)]
#[doc(hidden)]
unsafe extern "system" fn __Foo_Foo_Raw_simple_result_method_Raw(self_vtable:
                                                                     intercom::RawComPtr)
 ->
     <u16 as
intercom::type_system::ExternType<intercom::type_system::RawTypeSystem>>::ExternOutputType{
    let self_combox =
        (self_vtable as usize -
             <Foo as
                 intercom::attributes::ComClass<Foo,
                                                intercom::type_system::RawTypeSystem>>::offset())
            as *mut intercom::ComBoxData<Foo>;
    use intercom::type_system::{IntercomFrom, IntercomInto};
    let result:
            Result<<u16 as
                   intercom::type_system::ExternType<intercom::type_system::RawTypeSystem>>::ExternOutputType,
                   intercom::ComError> =
        (||
             {
                 intercom::logging::trace(|l|
                                              l("testcrate",
                                                ::core::fmt::Arguments::new_v1(&["[",
                                                                                 ", through ",
                                                                                 "] Serving ",
                                                                                 "::"],
                                                                               &match (&self_combox,
                                                                                       &self_vtable,
                                                                                       &"Foo",
                                                                                       &"simple_result_method")
                                                                                    {
                                                                                    (arg0,
                                                                                     arg1,
                                                                                     arg2,
                                                                                     arg3)
                                                                                    =>
                                                                                    [::core::fmt::ArgumentV1::new(arg0,
                                                                                                                  ::core::fmt::Pointer::fmt),
                                                                                     ::core::fmt::ArgumentV1::new(arg1,
                                                                                                                  ::core::fmt::Pointer::fmt),
                                                                                     ::core::fmt::ArgumentV1::new(arg2,
                                                                                                                  ::core::fmt::Display::fmt),
                                                                                     ::core::fmt::ArgumentV1::new(arg3,
                                                                                                                  ::core::fmt::Display::fmt)],
                                                                                })));
                 let self_struct: &Foo = &**self_combox;
                 let __result = self_struct.simple_result_method();
                 Ok({ __result.intercom_into()? })
             })();
    use intercom::ErrorValue;
    match result {
        Ok(v) => {
            intercom::logging::trace(|l| {
                l(
                    "testcrate",
                    ::core::fmt::Arguments::new_v1(
                        &["[", ", through ", "] Serving ", "::", ", OK"],
                        &match (&self_combox, &self_vtable, &"Foo", &"simple_result_method") {
                            (arg0, arg1, arg2, arg3) => [
                                ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Pointer::fmt),
                                ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Pointer::fmt),
                                ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                                ::core::fmt::ArgumentV1::new(arg3, ::core::fmt::Display::fmt),
                            ],
                        },
                    ),
                )
            });
            v
        }
        Err(err) => {
            intercom::logging::trace(|l| {
                l(
                    "testcrate",
                    ::core::fmt::Arguments::new_v1(
                        &["[", ", through ", "] Serving ", "::", ", ERROR"],
                        &match (&self_combox, &self_vtable, &"Foo", &"simple_result_method") {
                            (arg0, arg1, arg2, arg3) => [
                                ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Pointer::fmt),
                                ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Pointer::fmt),
                                ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                                ::core::fmt::ArgumentV1::new(arg3, ::core::fmt::Display::fmt),
                            ],
                        },
                    ),
                )
            });
            <<u16 as
             intercom::type_system::ExternType<intercom::type_system::RawTypeSystem>>::ExternOutputType
                as ErrorValue>::from_error(intercom::store_error(err))
        }
    }
}
#[allow(non_snake_case)]
#[allow(dead_code)]
#[doc(hidden)]
unsafe extern "system" fn __Foo_Foo_Raw_com_result_method_Raw(
    self_vtable: intercom::RawComPtr,
    __out:
                                                                  *mut <u16 as
                                                                       intercom::type_system::ExternType<intercom::type_system::RawTypeSystem>>::ExternOutputType,
) -> <intercom::raw::HRESULT as intercom::type_system::ExternType<
    intercom::type_system::RawTypeSystem,
>>::ExternOutputType {
    let self_combox =
        (self_vtable as usize -
             <Foo as
                 intercom::attributes::ComClass<Foo,
                                                intercom::type_system::RawTypeSystem>>::offset())
            as *mut intercom::ComBoxData<Foo>;
    use intercom::type_system::{IntercomFrom, IntercomInto};
    let result: Result<
        <intercom::raw::HRESULT as intercom::type_system::ExternType<
            intercom::type_system::RawTypeSystem,
        >>::ExternOutputType,
        intercom::ComError,
    > = (|| {
        intercom::logging::trace(|l| {
            l(
                "testcrate",
                ::core::fmt::Arguments::new_v1(
                    &["[", ", through ", "] Serving ", "::"],
                    &match (&self_combox, &self_vtable, &"Foo", &"com_result_method") {
                        (arg0, arg1, arg2, arg3) => [
                            ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Pointer::fmt),
                            ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Pointer::fmt),
                            ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                            ::core::fmt::ArgumentV1::new(arg3, ::core::fmt::Display::fmt),
                        ],
                    },
                ),
            )
        });
        let self_struct: &Foo = &**self_combox;
        let __result = self_struct.com_result_method();
        Ok({
            match __result {
                Ok(v1) => {
                    *__out = v1.intercom_into()?;
                    intercom::raw::S_OK
                }
                Err(e) => {
                    *__out = intercom::type_system::ExternDefault::extern_default();
                    intercom::store_error(e).hresult
                }
            }
        })
    })();
    use intercom::ErrorValue;
    match result {
        Ok(v) => {
            intercom::logging::trace(|l| {
                l(
                    "testcrate",
                    ::core::fmt::Arguments::new_v1(
                        &["[", ", through ", "] Serving ", "::", ", OK"],
                        &match (&self_combox, &self_vtable, &"Foo", &"com_result_method") {
                            (arg0, arg1, arg2, arg3) => [
                                ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Pointer::fmt),
                                ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Pointer::fmt),
                                ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                                ::core::fmt::ArgumentV1::new(arg3, ::core::fmt::Display::fmt),
                            ],
                        },
                    ),
                )
            });
            v
        }
        Err(err) => {
            intercom::logging::trace(|l| {
                l(
                    "testcrate",
                    ::core::fmt::Arguments::new_v1(
                        &["[", ", through ", "] Serving ", "::", ", ERROR"],
                        &match (&self_combox, &self_vtable, &"Foo", &"com_result_method") {
                            (arg0, arg1, arg2, arg3) => [
                                ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Pointer::fmt),
                                ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Pointer::fmt),
                                ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                                ::core::fmt::ArgumentV1::new(arg3, ::core::fmt::Display::fmt),
                            ],
                        },
                    ),
                )
            });
            <<intercom::raw::HRESULT as intercom::type_system::ExternType<
                intercom::type_system::RawTypeSystem,
            >>::ExternOutputType as ErrorValue>::from_error(intercom::store_error(err))
        }
    }
}
#[allow(non_snake_case)]
#[allow(dead_code)]
#[doc(hidden)]
unsafe extern "system" fn __Foo_Foo_Raw_rust_result_method_Raw(
    self_vtable: intercom::RawComPtr,
    __out:
                                                                   *mut <u16
                                                                        as
                                                                        intercom::type_system::ExternType<intercom::type_system::RawTypeSystem>>::ExternOutputType,
) -> <intercom::raw::HRESULT as intercom::type_system::ExternType<
    intercom::type_system::RawTypeSystem,
>>::ExternOutputType {
    let self_combox =
        (self_vtable as usize -
             <Foo as
                 intercom::attributes::ComClass<Foo,
                                                intercom::type_system::RawTypeSystem>>::offset())
            as *mut intercom::ComBoxData<Foo>;
    use intercom::type_system::{IntercomFrom, IntercomInto};
    let result: Result<
        <intercom::raw::HRESULT as intercom::type_system::ExternType<
            intercom::type_system::RawTypeSystem,
        >>::ExternOutputType,
        intercom::ComError,
    > = (|| {
        intercom::logging::trace(|l| {
            l(
                "testcrate",
                ::core::fmt::Arguments::new_v1(
                    &["[", ", through ", "] Serving ", "::"],
                    &match (&self_combox, &self_vtable, &"Foo", &"rust_result_method") {
                        (arg0, arg1, arg2, arg3) => [
                            ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Pointer::fmt),
                            ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Pointer::fmt),
                            ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                            ::core::fmt::ArgumentV1::new(arg3, ::core::fmt::Display::fmt),
                        ],
                    },
                ),
            )
        });
        let self_struct: &Foo = &**self_combox;
        let __result = self_struct.rust_result_method();
        Ok({
            match __result {
                Ok(v1) => {
                    *__out = v1.intercom_into()?;
                    intercom::raw::S_OK
                }
                Err(e) => {
                    *__out = intercom::type_system::ExternDefault::extern_default();
                    intercom::store_error(e).hresult
                }
            }
        })
    })();
    use intercom::ErrorValue;
    match result {
        Ok(v) => {
            intercom::logging::trace(|l| {
                l(
                    "testcrate",
                    ::core::fmt::Arguments::new_v1(
                        &["[", ", through ", "] Serving ", "::", ", OK"],
                        &match (&self_combox, &self_vtable, &"Foo", &"rust_result_method") {
                            (arg0, arg1, arg2, arg3) => [
                                ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Pointer::fmt),
                                ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Pointer::fmt),
                                ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                                ::core::fmt::ArgumentV1::new(arg3, ::core::fmt::Display::fmt),
                            ],
                        },
                    ),
                )
            });
            v
        }
        Err(err) => {
            intercom::logging::trace(|l| {
                l(
                    "testcrate",
                    ::core::fmt::Arguments::new_v1(
                        &["[", ", through ", "] Serving ", "::", ", ERROR"],
                        &match (&self_combox, &self_vtable, &"Foo", &"rust_result_method") {
                            (arg0, arg1, arg2, arg3) => [
                                ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Pointer::fmt),
                                ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Pointer::fmt),
                                ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                                ::core::fmt::ArgumentV1::new(arg3, ::core::fmt::Display::fmt),
                            ],
                        },
                    ),
                )
            });
            <<intercom::raw::HRESULT as intercom::type_system::ExternType<
                intercom::type_system::RawTypeSystem,
            >>::ExternOutputType as ErrorValue>::from_error(intercom::store_error(err))
        }
    }
}
#[allow(non_snake_case)]
#[allow(dead_code)]
#[doc(hidden)]
unsafe extern "system" fn __Foo_Foo_Raw_tuple_result_method_Raw(
    self_vtable: intercom::RawComPtr,
    __out1:
                                                                    *mut <u8
                                                                         as
                                                                         intercom::type_system::ExternType<intercom::type_system::RawTypeSystem>>::ExternOutputType,
    __out2:
                                                                    *mut <u16
                                                                         as
                                                                         intercom::type_system::ExternType<intercom::type_system::RawTypeSystem>>::ExternOutputType,
    __out3:
                                                                    *mut <u32
                                                                         as
                                                                         intercom::type_system::ExternType<intercom::type_system::RawTypeSystem>>::ExternOutputType,
) -> <intercom::raw::HRESULT as intercom::type_system::ExternType<
    intercom::type_system::RawTypeSystem,
>>::ExternOutputType {
    let self_combox =
        (self_vtable as usize -
             <Foo as
                 intercom::attributes::ComClass<Foo,
                                                intercom::type_system::RawTypeSystem>>::offset())
            as *mut intercom::ComBoxData<Foo>;
    use intercom::type_system::{IntercomFrom, IntercomInto};
    let result: Result<
        <intercom::raw::HRESULT as intercom::type_system::ExternType<
            intercom::type_system::RawTypeSystem,
        >>::ExternOutputType,
        intercom::ComError,
    > = (|| {
        intercom::logging::trace(|l| {
            l(
                "testcrate",
                ::core::fmt::Arguments::new_v1(
                    &["[", ", through ", "] Serving ", "::"],
                    &match (&self_combox, &self_vtable, &"Foo", &"tuple_result_method") {
                        (arg0, arg1, arg2, arg3) => [
                            ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Pointer::fmt),
                            ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Pointer::fmt),
                            ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                            ::core::fmt::ArgumentV1::new(arg3, ::core::fmt::Display::fmt),
                        ],
                    },
                ),
            )
        });
        let self_struct: &Foo = &**self_combox;
        let __result = self_struct.tuple_result_method();
        Ok({
            match __result {
                Ok((v1, v2, v3)) => {
                    *__out1 = v1.intercom_into()?;
                    *__out2 = v2.intercom_into()?;
                    *__out3 = v3.intercom_into()?;
                    intercom::raw::S_OK
                }
                Err(e) => {
                    *__out1 = intercom::type_system::ExternDefault::extern_default();
                    *__out2 = intercom::type_system::ExternDefault::extern_default();
                    *__out3 = intercom::type_system::ExternDefault::extern_default();
                    intercom::store_error(e).hresult
                }
            }
        })
    })();
    use intercom::ErrorValue;
    match result {
        Ok(v) => {
            intercom::logging::trace(|l| {
                l(
                    "testcrate",
                    ::core::fmt::Arguments::new_v1(
                        &["[", ", through ", "] Serving ", "::", ", OK"],
                        &match (&self_combox, &self_vtable, &"Foo", &"tuple_result_method") {
                            (arg0, arg1, arg2, arg3) => [
                                ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Pointer::fmt),
                                ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Pointer::fmt),
                                ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                                ::core::fmt::ArgumentV1::new(arg3, ::core::fmt::Display::fmt),
                            ],
                        },
                    ),
                )
            });
            v
        }
        Err(err) => {
            intercom::logging::trace(|l| {
                l(
                    "testcrate",
                    ::core::fmt::Arguments::new_v1(
                        &["[", ", through ", "] Serving ", "::", ", ERROR"],
                        &match (&self_combox, &self_vtable, &"Foo", &"tuple_result_method") {
                            (arg0, arg1, arg2, arg3) => [
                                ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Pointer::fmt),
                                ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Pointer::fmt),
                                ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                                ::core::fmt::ArgumentV1::new(arg3, ::core::fmt::Display::fmt),
                            ],
                        },
                    ),
                )
            });
            <<intercom::raw::HRESULT as intercom::type_system::ExternType<
                intercom::type_system::RawTypeSystem,
            >>::ExternOutputType as ErrorValue>::from_error(intercom::store_error(err))
        }
    }
}
#[allow(non_snake_case)]
#[allow(dead_code)]
#[doc(hidden)]
unsafe extern "system" fn __Foo_Foo_Raw_string_method_Raw(self_vtable:
                                                              intercom::RawComPtr,
                                                          input:
                                                              <String as
                                                              intercom::type_system::ExternType<intercom::type_system::RawTypeSystem>>::ExternInputType)
 ->
     <String as
intercom::type_system::ExternType<intercom::type_system::RawTypeSystem>>::ExternOutputType{
    let self_combox =
        (self_vtable as usize -
             <Foo as
                 intercom::attributes::ComClass<Foo,
                                                intercom::type_system::RawTypeSystem>>::offset())
            as *mut intercom::ComBoxData<Foo>;
    use intercom::type_system::{IntercomFrom, IntercomInto};
    let result:
            Result<<String as
                   intercom::type_system::ExternType<intercom::type_system::RawTypeSystem>>::ExternOutputType,
                   intercom::ComError> =
        (||
             {
                 intercom::logging::trace(|l|
                                              l("testcrate",
                                                ::core::fmt::Arguments::new_v1(&["[",
                                                                                 ", through ",
                                                                                 "] Serving ",
                                                                                 "::"],
                                                                               &match (&self_combox,
                                                                                       &self_vtable,
                                                                                       &"Foo",
                                                                                       &"string_method")
                                                                                    {
                                                                                    (arg0,
                                                                                     arg1,
                                                                                     arg2,
                                                                                     arg3)
                                                                                    =>
                                                                                    [::core::fmt::ArgumentV1::new(arg0,
                                                                                                                  ::core::fmt::Pointer::fmt),
                                                                                     ::core::fmt::ArgumentV1::new(arg1,
                                                                                                                  ::core::fmt::Pointer::fmt),
                                                                                     ::core::fmt::ArgumentV1::new(arg2,
                                                                                                                  ::core::fmt::Display::fmt),
                                                                                     ::core::fmt::ArgumentV1::new(arg3,
                                                                                                                  ::core::fmt::Display::fmt)],
                                                                                })));
                 let self_struct: &Foo = &**self_combox;
                 let __result =
                     self_struct.string_method((<String as
                                                    intercom::type_system::ExternType<intercom::type_system::RawTypeSystem>>::intercom_from(input)?).intercom_into()?);
                 Ok({ __result.intercom_into()? })
             })();
    use intercom::ErrorValue;
    match result {
        Ok(v) => {
            intercom::logging::trace(|l| {
                l(
                    "testcrate",
                    ::core::fmt::Arguments::new_v1(
                        &["[", ", through ", "] Serving ", "::", ", OK"],
                        &match (&self_combox, &self_vtable, &"Foo", &"string_method") {
                            (arg0, arg1, arg2, arg3) => [
                                ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Pointer::fmt),
                                ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Pointer::fmt),
                                ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                                ::core::fmt::ArgumentV1::new(arg3, ::core::fmt::Display::fmt),
                            ],
                        },
                    ),
                )
            });
            v
        }
        Err(err) => {
            intercom::logging::trace(|l| {
                l(
                    "testcrate",
                    ::core::fmt::Arguments::new_v1(
                        &["[", ", through ", "] Serving ", "::", ", ERROR"],
                        &match (&self_combox, &self_vtable, &"Foo", &"string_method") {
                            (arg0, arg1, arg2, arg3) => [
                                ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Pointer::fmt),
                                ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Pointer::fmt),
                                ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                                ::core::fmt::ArgumentV1::new(arg3, ::core::fmt::Display::fmt),
                            ],
                        },
                    ),
                )
            });
            <<String as
             intercom::type_system::ExternType<intercom::type_system::RawTypeSystem>>::ExternOutputType
                as ErrorValue>::from_error(intercom::store_error(err))
        }
    }
}
#[allow(non_snake_case)]
#[allow(dead_code)]
#[doc(hidden)]
unsafe extern "system" fn __Foo_Foo_Raw_string_result_method_Raw(
    self_vtable: intercom::RawComPtr,
    input:
                                                                     <String
                                                                     as
                                                                     intercom::type_system::ExternType<intercom::type_system::RawTypeSystem>>::ExternInputType,
    __out: *mut <String as intercom::type_system::ExternType<
        intercom::type_system::RawTypeSystem,
    >>::ExternOutputType,
) -> <intercom::raw::HRESULT as intercom::type_system::ExternType<
    intercom::type_system::RawTypeSystem,
>>::ExternOutputType {
    let self_combox =
        (self_vtable as usize -
             <Foo as
                 intercom::attributes::ComClass<Foo,
                                                intercom::type_system::RawTypeSystem>>::offset())
            as *mut intercom::ComBoxData<Foo>;
    use intercom::type_system::{IntercomFrom, IntercomInto};
    let result: Result<
        <intercom::raw::HRESULT as intercom::type_system::ExternType<
            intercom::type_system::RawTypeSystem,
        >>::ExternOutputType,
        intercom::ComError,
    > = (|| {
        intercom::logging::trace(|l| {
            l(
                "testcrate",
                ::core::fmt::Arguments::new_v1(
                    &["[", ", through ", "] Serving ", "::"],
                    &match (&self_combox, &self_vtable, &"Foo", &"string_result_method") {
                        (arg0, arg1, arg2, arg3) => [
                            ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Pointer::fmt),
                            ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Pointer::fmt),
                            ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                            ::core::fmt::ArgumentV1::new(arg3, ::core::fmt::Display::fmt),
                        ],
                    },
                ),
            )
        });
        let self_struct: &Foo = &**self_combox;
        let __result = self_struct.string_result_method(
            (<String as intercom::type_system::ExternType<
                intercom::type_system::RawTypeSystem,
            >>::intercom_from(input)?)
            .intercom_into()?,
        );
        Ok({
            match __result {
                Ok(v1) => {
                    *__out = v1.intercom_into()?;
                    intercom::raw::S_OK
                }
                Err(e) => {
                    *__out = intercom::type_system::ExternDefault::extern_default();
                    intercom::store_error(e).hresult
                }
            }
        })
    })();
    use intercom::ErrorValue;
    match result {
        Ok(v) => {
            intercom::logging::trace(|l| {
                l(
                    "testcrate",
                    ::core::fmt::Arguments::new_v1(
                        &["[", ", through ", "] Serving ", "::", ", OK"],
                        &match (&self_combox, &self_vtable, &"Foo", &"string_result_method") {
                            (arg0, arg1, arg2, arg3) => [
                                ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Pointer::fmt),
                                ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Pointer::fmt),
                                ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                                ::core::fmt::ArgumentV1::new(arg3, ::core::fmt::Display::fmt),
                            ],
                        },
                    ),
                )
            });
            v
        }
        Err(err) => {
            intercom::logging::trace(|l| {
                l(
                    "testcrate",
                    ::core::fmt::Arguments::new_v1(
                        &["[", ", through ", "] Serving ", "::", ", ERROR"],
                        &match (&self_combox, &self_vtable, &"Foo", &"string_result_method") {
                            (arg0, arg1, arg2, arg3) => [
                                ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Pointer::fmt),
                                ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Pointer::fmt),
                                ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                                ::core::fmt::ArgumentV1::new(arg3, ::core::fmt::Display::fmt),
                            ],
                        },
                    ),
                )
            });
            <<intercom::raw::HRESULT as intercom::type_system::ExternType<
                intercom::type_system::RawTypeSystem,
            >>::ExternOutputType as ErrorValue>::from_error(intercom::store_error(err))
        }
    }
}
#[allow(non_snake_case)]
#[allow(dead_code)]
#[doc(hidden)]
unsafe extern "system" fn __Foo_Foo_Raw_complete_method_Raw(
    self_vtable: intercom::RawComPtr,
    a:
                                                                <u16 as
                                                                intercom::type_system::ExternType<intercom::type_system::RawTypeSystem>>::ExternInputType,
    b:
                                                                <i16 as
                                                                intercom::type_system::ExternType<intercom::type_system::RawTypeSystem>>::ExternInputType,
    __out:
                                                                *mut <bool as
                                                                     intercom::type_system::ExternType<intercom::type_system::RawTypeSystem>>::ExternOutputType,
) -> <intercom::raw::HRESULT as intercom::type_system::ExternType<
    intercom::type_system::RawTypeSystem,
>>::ExternOutputType {
    let self_combox =
        (self_vtable as usize -
             <Foo as
                 intercom::attributes::ComClass<Foo,
                                                intercom::type_system::RawTypeSystem>>::offset())
            as *mut intercom::ComBoxData<Foo>;
    use intercom::type_system::{IntercomFrom, IntercomInto};
    let result: Result<
        <intercom::raw::HRESULT as intercom::type_system::ExternType<
            intercom::type_system::RawTypeSystem,
        >>::ExternOutputType,
        intercom::ComError,
    > = (|| {
        intercom::logging::trace(|l| {
            l(
                "testcrate",
                ::core::fmt::Arguments::new_v1(
                    &["[", ", through ", "] Serving ", "::"],
                    &match (&self_combox, &self_vtable, &"Foo", &"complete_method") {
                        (arg0, arg1, arg2, arg3) => [
                            ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Pointer::fmt),
                            ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Pointer::fmt),
                            ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                            ::core::fmt::ArgumentV1::new(arg3, ::core::fmt::Display::fmt),
                        ],
                    },
                ),
            )
        });
        let self_struct: &mut Foo = &mut **self_combox;
        let __result =
            self_struct.complete_method(
                (<u16 as intercom::type_system::ExternType<
                    intercom::type_system::RawTypeSystem,
                >>::intercom_from(a)?)
                .intercom_into()?,
                (<i16 as intercom::type_system::ExternType<
                    intercom::type_system::RawTypeSystem,
                >>::intercom_from(b)?)
                .intercom_into()?,
            );
        Ok({
            match __result {
                Ok(v1) => {
                    *__out = v1.intercom_into()?;
                    intercom::raw::S_OK
                }
                Err(e) => {
                    *__out = intercom::type_system::ExternDefault::extern_default();
                    intercom::store_error(e).hresult
                }
            }
        })
    })();
    use intercom::ErrorValue;
    match result {
        Ok(v) => {
            intercom::logging::trace(|l| {
                l(
                    "testcrate",
                    ::core::fmt::Arguments::new_v1(
                        &["[", ", through ", "] Serving ", "::", ", OK"],
                        &match (&self_combox, &self_vtable, &"Foo", &"complete_method") {
                            (arg0, arg1, arg2, arg3) => [
                                ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Pointer::fmt),
                                ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Pointer::fmt),
                                ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                                ::core::fmt::ArgumentV1::new(arg3, ::core::fmt::Display::fmt),
                            ],
                        },
                    ),
                )
            });
            v
        }
        Err(err) => {
            intercom::logging::trace(|l| {
                l(
                    "testcrate",
                    ::core::fmt::Arguments::new_v1(
                        &["[", ", through ", "] Serving ", "::", ", ERROR"],
                        &match (&self_combox, &self_vtable, &"Foo", &"complete_method") {
                            (arg0, arg1, arg2, arg3) => [
                                ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Pointer::fmt),
                                ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Pointer::fmt),
                                ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                                ::core::fmt::ArgumentV1::new(arg3, ::core::fmt::Display::fmt),
                            ],
                        },
                    ),
                )
            });
            <<intercom::raw::HRESULT as intercom::type_system::ExternType<
                intercom::type_system::RawTypeSystem,
            >>::ExternOutputType as ErrorValue>::from_error(intercom::store_error(err))
        }
    }
}
#[allow(non_snake_case)]
#[allow(dead_code)]
#[doc(hidden)]
unsafe extern "system" fn __Foo_Foo_Raw_bool_method_Raw(
    self_vtable: intercom::RawComPtr,
    input:
                                                            <bool as
                                                            intercom::type_system::ExternType<intercom::type_system::RawTypeSystem>>::ExternInputType,
    __out:
                                                            *mut <bool as
                                                                 intercom::type_system::ExternType<intercom::type_system::RawTypeSystem>>::ExternOutputType,
) -> <intercom::raw::HRESULT as intercom::type_system::ExternType<
    intercom::type_system::RawTypeSystem,
>>::ExternOutputType {
    let self_combox =
        (self_vtable as usize -
             <Foo as
                 intercom::attributes::ComClass<Foo,
                                                intercom::type_system::RawTypeSystem>>::offset())
            as *mut intercom::ComBoxData<Foo>;
    use intercom::type_system::{IntercomFrom, IntercomInto};
    let result: Result<
        <intercom::raw::HRESULT as intercom::type_system::ExternType<
            intercom::type_system::RawTypeSystem,
        >>::ExternOutputType,
        intercom::ComError,
    > = (|| {
        intercom::logging::trace(|l| {
            l(
                "testcrate",
                ::core::fmt::Arguments::new_v1(
                    &["[", ", through ", "] Serving ", "::"],
                    &match (&self_combox, &self_vtable, &"Foo", &"bool_method") {
                        (arg0, arg1, arg2, arg3) => [
                            ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Pointer::fmt),
                            ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Pointer::fmt),
                            ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                            ::core::fmt::ArgumentV1::new(arg3, ::core::fmt::Display::fmt),
                        ],
                    },
                ),
            )
        });
        let self_struct: &Foo = &**self_combox;
        let __result =
            self_struct.bool_method(
                (<bool as intercom::type_system::ExternType<
                    intercom::type_system::RawTypeSystem,
                >>::intercom_from(input)?)
                .intercom_into()?,
            );
        Ok({
            match __result {
                Ok(v1) => {
                    *__out = v1.intercom_into()?;
                    intercom::raw::S_OK
                }
                Err(e) => {
                    *__out = intercom::type_system::ExternDefault::extern_default();
                    intercom::store_error(e).hresult
                }
            }
        })
    })();
    use intercom::ErrorValue;
    match result {
        Ok(v) => {
            intercom::logging::trace(|l| {
                l(
                    "testcrate",
                    ::core::fmt::Arguments::new_v1(
                        &["[", ", through ", "] Serving ", "::", ", OK"],
                        &match (&self_combox, &self_vtable, &"Foo", &"bool_method") {
                            (arg0, arg1, arg2, arg3) => [
                                ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Pointer::fmt),
                                ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Pointer::fmt),
                                ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                                ::core::fmt::ArgumentV1::new(arg3, ::core::fmt::Display::fmt),
                            ],
                        },
                    ),
                )
            });
            v
        }
        Err(err) => {
            intercom::logging::trace(|l| {
                l(
                    "testcrate",
                    ::core::fmt::Arguments::new_v1(
                        &["[", ", through ", "] Serving ", "::", ", ERROR"],
                        &match (&self_combox, &self_vtable, &"Foo", &"bool_method") {
                            (arg0, arg1, arg2, arg3) => [
                                ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Pointer::fmt),
                                ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Pointer::fmt),
                                ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                                ::core::fmt::ArgumentV1::new(arg3, ::core::fmt::Display::fmt),
                            ],
                        },
                    ),
                )
            });
            <<intercom::raw::HRESULT as intercom::type_system::ExternType<
                intercom::type_system::RawTypeSystem,
            >>::ExternOutputType as ErrorValue>::from_error(intercom::store_error(err))
        }
    }
}
#[allow(non_snake_case)]
#[allow(dead_code)]
#[doc(hidden)]
unsafe extern "system" fn __Foo_Foo_Raw_variant_method_Raw(
    self_vtable: intercom::RawComPtr,
    input:
                                                               <Variant as
                                                               intercom::type_system::ExternType<intercom::type_system::RawTypeSystem>>::ExternInputType,
    __out: *mut <Variant as intercom::type_system::ExternType<
        intercom::type_system::RawTypeSystem,
    >>::ExternOutputType,
) -> <intercom::raw::HRESULT as intercom::type_system::ExternType<
    intercom::type_system::RawTypeSystem,
>>::ExternOutputType {
    let self_combox =
        (self_vtable as usize -
             <Foo as
                 intercom::attributes::ComClass<Foo,
                                                intercom::type_system::RawTypeSystem>>::offset())
            as *mut intercom::ComBoxData<Foo>;
    use intercom::type_system::{IntercomFrom, IntercomInto};
    let result: Result<
        <intercom::raw::HRESULT as intercom::type_system::ExternType<
            intercom::type_system::RawTypeSystem,
        >>::ExternOutputType,
        intercom::ComError,
    > = (|| {
        intercom::logging::trace(|l| {
            l(
                "testcrate",
                ::core::fmt::Arguments::new_v1(
                    &["[", ", through ", "] Serving ", "::"],
                    &match (&self_combox, &self_vtable, &"Foo", &"variant_method") {
                        (arg0, arg1, arg2, arg3) => [
                            ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Pointer::fmt),
                            ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Pointer::fmt),
                            ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                            ::core::fmt::ArgumentV1::new(arg3, ::core::fmt::Display::fmt),
                        ],
                    },
                ),
            )
        });
        let self_struct: &Foo = &**self_combox;
        let __result = self_struct.variant_method(
            (<Variant as intercom::type_system::ExternType<
                intercom::type_system::RawTypeSystem,
            >>::intercom_from(input)?)
            .intercom_into()?,
        );
        Ok({
            match __result {
                Ok(v1) => {
                    *__out = v1.intercom_into()?;
                    intercom::raw::S_OK
                }
                Err(e) => {
                    *__out = intercom::type_system::ExternDefault::extern_default();
                    intercom::store_error(e).hresult
                }
            }
        })
    })();
    use intercom::ErrorValue;
    match result {
        Ok(v) => {
            intercom::logging::trace(|l| {
                l(
                    "testcrate",
                    ::core::fmt::Arguments::new_v1(
                        &["[", ", through ", "] Serving ", "::", ", OK"],
                        &match (&self_combox, &self_vtable, &"Foo", &"variant_method") {
                            (arg0, arg1, arg2, arg3) => [
                                ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Pointer::fmt),
                                ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Pointer::fmt),
                                ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                                ::core::fmt::ArgumentV1::new(arg3, ::core::fmt::Display::fmt),
                            ],
                        },
                    ),
                )
            });
            v
        }
        Err(err) => {
            intercom::logging::trace(|l| {
                l(
                    "testcrate",
                    ::core::fmt::Arguments::new_v1(
                        &["[", ", through ", "] Serving ", "::", ", ERROR"],
                        &match (&self_combox, &self_vtable, &"Foo", &"variant_method") {
                            (arg0, arg1, arg2, arg3) => [
                                ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Pointer::fmt),
                                ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Pointer::fmt),
                                ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                                ::core::fmt::ArgumentV1::new(arg3, ::core::fmt::Display::fmt),
                            ],
                        },
                    ),
                )
            });
            <<intercom::raw::HRESULT as intercom::type_system::ExternType<
                intercom::type_system::RawTypeSystem,
            >>::ExternOutputType as ErrorValue>::from_error(intercom::store_error(err))
        }
    }
}
#[allow(non_upper_case_globals)]
impl intercom::attributes::ComImpl<Foo, intercom::type_system::RawTypeSystem> for Foo {
    fn vtable()
     ->
         &'static <Foo as
intercom::attributes::ComInterface<intercom::type_system::RawTypeSystem>>::VTable{
        type T = <Foo as intercom::attributes::ComInterface<
            intercom::type_system::RawTypeSystem,
        >>::VTable;
        &T {
            __base: {
                type TVtbl = <dyn intercom::IUnknown as intercom::attributes::ComInterface<
                    intercom::type_system::AutomationTypeSystem,
                >>::VTable;
                TVtbl {
                    query_interface: __Foo_Foo_Raw_query_interface,
                    add_ref: __Foo_Foo_Raw_add_ref,
                    release: __Foo_Foo_Raw_release,
                }
            },
            simple_method: __Foo_Foo_Raw_simple_method_Raw,
            arg_method: __Foo_Foo_Raw_arg_method_Raw,
            simple_result_method: __Foo_Foo_Raw_simple_result_method_Raw,
            com_result_method: __Foo_Foo_Raw_com_result_method_Raw,
            rust_result_method: __Foo_Foo_Raw_rust_result_method_Raw,
            tuple_result_method: __Foo_Foo_Raw_tuple_result_method_Raw,
            string_method: __Foo_Foo_Raw_string_method_Raw,
            string_result_method: __Foo_Foo_Raw_string_result_method_Raw,
            complete_method: __Foo_Foo_Raw_complete_method_Raw,
            bool_method: __Foo_Foo_Raw_bool_method_Raw,
            variant_method: __Foo_Foo_Raw_variant_method_Raw,
        }
    }
}
impl intercom::HasInterface<Foo> for Foo {}
